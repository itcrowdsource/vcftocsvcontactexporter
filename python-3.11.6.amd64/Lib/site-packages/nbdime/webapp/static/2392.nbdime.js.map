{"version":3,"file":"2392.nbdime.js","mappings":"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","sources":["webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/adaptors/HTMLAdaptor.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/adaptors/browserAdaptor.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/core/DOMAdaptor.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the HTML DOM adaptor\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {OptionList} from '../util/Options.js';\nimport {AttributeData, AbstractDOMAdaptor, DOMAdaptor, PageBBox} from '../core/DOMAdaptor.js';\n\n/*****************************************************************/\n/**\n * The minimum fields needed for a Document\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport interface MinDocument<N, T> {\n  documentElement: N;\n  head: N;\n  body: N;\n  title: string;\n  doctype: {name: string};\n  /* tslint:disable:jsdoc-require */\n  createElement(kind: string): N;\n  createElementNS(ns: string, kind: string): N;\n  createTextNode(text: string): T;\n  querySelectorAll(selector: string): ArrayLike<N>;\n  /* tslint:enable */\n}\n\n/*****************************************************************/\n/**\n * The minimum fields needed for an HTML Element\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport interface MinHTMLElement<N, T> {\n  nodeType: number;\n  nodeName: string;\n  nodeValue: string;\n  textContent: string;\n  innerHTML: string;\n  outerHTML: string;\n  parentNode: N | Node;\n  nextSibling: N | T | Node;\n  previousSibling: N | T | Node;\n  offsetWidth: number;\n  offsetHeight: number;\n\n  attributes: AttributeData[] | NamedNodeMap;\n  className: string;\n  classList: DOMTokenList;\n  style: OptionList;\n  sheet?: {insertRule: (rule: string, index?: number) => void};\n\n  childNodes: (N | T)[] | NodeList;\n  firstChild: N | T | Node;\n  lastChild: N | T | Node;\n  /* tslint:disable:jsdoc-require */\n  getElementsByTagName(name: string): N[] | HTMLCollectionOf<Element>;\n  getElementsByTagNameNS(ns: string, name: string): N[] | HTMLCollectionOf<Element>;\n  contains(child: N | T): boolean;\n  appendChild(child: N | T): N | T | Node;\n  removeChild(child: N | T): N | T  | Node;\n  replaceChild(nnode: N | T, onode: N | T): N | T  | Node;\n  insertBefore(nchild: N | T, ochild: N | T): void;\n  cloneNode(deep: boolean): N | Node;\n  setAttribute(name: string, value: string): void;\n  setAttributeNS(ns: string, name: string, value: string): void;\n  getAttribute(name: string): string;\n  removeAttribute(name: string): void;\n  hasAttribute(name: string): boolean;\n  getBoundingClientRect(): Object;\n  getBBox?(): {x: number, y: number, width: number, height: number};\n  /* tslint:endable */\n}\n\n/*****************************************************************/\n/**\n * The minimum fields needed for a Text element\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport interface MinText<N, T> {\n  nodeType: number;\n  nodeName: string;\n  nodeValue: string;\n  parentNode: N | Node;\n  nextSibling: N | T | Node;\n  previousSibling: N | T | Node;\n  splitText(n: number): T;\n}\n\n/*****************************************************************/\n/**\n * The minimum fields needed for a DOMParser\n *\n * @template D  The Document class\n */\nexport interface MinDOMParser<D> {\n  parseFromString(text: string, format?: string): D;\n}\n\n/*****************************************************************/\n/**\n * The minimum fields needed for a DOMParser\n *\n * @template N  The HTMLElement node class\n */\nexport interface MinXMLSerializer<N> {\n  serializeToString(node: N): string;\n}\n\n/*****************************************************************/\n/**\n * The minimum fields needed for a Window\n *\n * @template N  The HTMLElement node class\n * @template D  The Document class\n */\nexport interface MinWindow<N, D> {\n  document: D;\n  DOMParser: {\n    new(): MinDOMParser<D>\n  };\n  XMLSerializer: {\n    new(): MinXMLSerializer<N>;\n  };\n  NodeList: any;\n  HTMLCollection: any;\n  HTMLElement: any;\n  DocumentFragment: any;\n  Document: any;\n  getComputedStyle(node: N): any;\n}\n\n/*****************************************************************/\n/**\n * The minimum needed for an HTML Adaptor\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport interface MinHTMLAdaptor<N, T, D> extends DOMAdaptor<N, T, D> {\n  window: MinWindow<N, D>;\n}\n\n/*****************************************************************/\n/**\n *  Abstract HTMLAdaptor class for manipulating HTML elements\n *  (subclass of AbstractDOMAdaptor)\n *\n *  N = HTMLElement node class\n *  T = Text node class\n *  D = Document class\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport class HTMLAdaptor<N extends MinHTMLElement<N, T>, T extends MinText<N, T>, D extends MinDocument<N, T>> extends\nAbstractDOMAdaptor<N, T, D> implements MinHTMLAdaptor<N, T, D> {\n  /**\n   * The window object for this adaptor\n   */\n  public window: MinWindow<N, D>;\n\n  /**\n   * The DOMParser used to parse a string into a DOM tree\n   */\n  public parser: MinDOMParser<D>;\n\n  /**\n   * @override\n   * @constructor\n   */\n  constructor(window: MinWindow<N, D>) {\n    super(window.document);\n    this.window = window;\n    this.parser = new (window.DOMParser as any)();\n  }\n\n  /**\n   * @override\n   */\n  public parse(text: string, format: string = 'text/html') {\n    return this.parser.parseFromString(text, format);\n  }\n\n  /**\n   * @override\n   */\n  protected create(kind: string, ns?: string) {\n    return (ns ?\n            this.document.createElementNS(ns, kind) :\n            this.document.createElement(kind));\n  }\n\n  /**\n   * @override\n   */\n  public text(text: string) {\n    return this.document.createTextNode(text);\n  }\n\n  /**\n   * @override\n   */\n  public head(doc: D) {\n    return doc.head || (doc as any as N);\n  }\n\n  /**\n   * @override\n   */\n  public body(doc: D) {\n    return doc.body || (doc as any as N);\n  }\n\n  /**\n   * @override\n   */\n  public root(doc: D) {\n    return doc.documentElement || (doc as any as N);\n  }\n\n  /**\n   * @override\n   */\n  public doctype(doc: D) {\n    return (doc.doctype ? `<!DOCTYPE ${doc.doctype.name}>` : '');\n  }\n\n  /**\n   * @override\n   */\n  public tags(node: N, name: string, ns: string = null) {\n    let nodes = (ns ? node.getElementsByTagNameNS(ns, name) : node.getElementsByTagName(name));\n    return Array.from(nodes as N[]) as N[];\n  }\n\n  /**\n   * @override\n   */\n  public getElements(nodes: (string | N | N[])[], _document: D) {\n    let containers: N[] = [];\n    for (const node of nodes) {\n      if (typeof(node) === 'string') {\n        containers = containers.concat(Array.from(this.document.querySelectorAll(node)));\n      } else if (Array.isArray(node)) {\n        containers = containers.concat(Array.from(node) as N[]);\n      } else if (node instanceof this.window.NodeList || node instanceof this.window.HTMLCollection) {\n        containers = containers.concat(Array.from(node as any as N[]));\n      } else {\n        containers.push(node);\n      }\n    }\n    return containers;\n  }\n\n  /**\n   * @override\n   */\n  public contains(container: N, node: N | T) {\n    return container.contains(node);\n  }\n\n  /**\n   * @override\n   */\n  public parent(node: N | T) {\n    return node.parentNode as N;\n  }\n\n  /**\n   * @override\n   */\n  public append(node: N, child: N | T) {\n    return node.appendChild(child) as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public insert(nchild: N | T, ochild: N | T) {\n    return this.parent(ochild).insertBefore(nchild, ochild);\n  }\n\n  /**\n   * @override\n   */\n  public remove(child: N | T) {\n    return this.parent(child).removeChild(child) as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public replace(nnode: N | T, onode: N | T) {\n    return this.parent(onode).replaceChild(nnode, onode) as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public clone(node: N) {\n    return node.cloneNode(true) as N;\n  }\n\n  /**\n   * @override\n   */\n  public split(node: T, n: number) {\n    return node.splitText(n);\n  }\n\n  /**\n   * @override\n   */\n  public next(node: N | T) {\n    return node.nextSibling as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public previous(node: N | T) {\n    return node.previousSibling as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public firstChild(node: N) {\n    return node.firstChild as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public lastChild(node: N) {\n    return node.lastChild as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public childNodes(node: N) {\n    return Array.from(node.childNodes as (N | T)[]);\n  }\n\n  /**\n   * @override\n   */\n  public childNode(node: N, i: number) {\n    return node.childNodes[i] as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public kind(node: N | T) {\n    const n = node.nodeType;\n    return (n === 1 || n === 3 || n === 8 ? node.nodeName.toLowerCase() : '');\n  }\n\n  /**\n   * @override\n   */\n  public value(node: N | T) {\n    return node.nodeValue || '';\n  }\n\n  /**\n   * @override\n   */\n  public textContent(node: N) {\n    return node.textContent;\n  }\n\n  /**\n   * @override\n   */\n  public innerHTML(node: N) {\n    return node.innerHTML;\n  }\n\n  /**\n   * @override\n   */\n  public outerHTML(node: N) {\n    return node.outerHTML;\n  }\n\n  public serializeXML(node: N) {\n    const serializer = new this.window.XMLSerializer();\n    return serializer.serializeToString(node) as string;\n  }\n\n  /**\n   * @override\n   */\n  public setAttribute(node: N, name: string, value: string, ns: string = null) {\n    if (!ns) {\n      return node.setAttribute(name, value);\n    }\n    name = ns.replace(/.*\\//, '') + ':' + name.replace(/^.*:/, '');\n    return node.setAttributeNS(ns, name, value);\n  }\n\n  /**\n   * @override\n   */\n  public getAttribute(node: N, name: string) {\n    return node.getAttribute(name);\n  }\n\n  /**\n   * @override\n   */\n  public removeAttribute(node: N, name: string) {\n    return node.removeAttribute(name);\n  }\n\n  /**\n   * @override\n   */\n  public hasAttribute(node: N, name: string) {\n    return node.hasAttribute(name);\n  }\n\n  /**\n   * @override\n   */\n  public allAttributes(node: N) {\n    return Array.from(node.attributes).map(\n      (x: AttributeData) => {\n        return {name: x.name, value: x.value} as AttributeData;\n      }\n    );\n  }\n\n  /**\n   * @override\n   */\n  public addClass(node: N, name: string) {\n    if (node.classList) {\n      node.classList.add(name);\n    } else {\n      node.className = (node.className + ' ' + name).trim();\n    }\n  }\n\n  /**\n   * @override\n   */\n  public removeClass(node: N, name: string) {\n    if (node.classList) {\n      node.classList.remove(name);\n    } else {\n      node.className = node.className.split(/ /).filter((c) => c !== name).join(' ');\n    }\n  }\n\n  /**\n   * @override\n   */\n  public hasClass(node: N, name: string) {\n    if (node.classList) {\n      return node.classList.contains(name);\n    }\n    return node.className.split(/ /).indexOf(name) >= 0;\n  }\n\n  /**\n   * @override\n   */\n  public setStyle(node: N, name: string, value: string) {\n    (node.style as OptionList)[name] = value;\n  }\n\n  /**\n   * @override\n   */\n  public getStyle(node: N, name: string) {\n    return (node.style as OptionList)[name];\n  }\n\n  /**\n   * @override\n   */\n  public allStyles(node: N) {\n    return node.style.cssText;\n  }\n\n  /**\n   * @override\n   */\n  public insertRules(node: N, rules: string[]) {\n    for (const rule of rules.reverse()) {\n      try {\n        node.sheet.insertRule(rule, 0);\n      } catch (e) {\n        console.warn(`MathJax: can't insert css rule '${rule}': ${e.message}`);\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  public fontSize(node: N) {\n    const style = this.window.getComputedStyle(node);\n    return parseFloat(style.fontSize);\n  }\n\n  /**\n   * @override\n   */\n  public fontFamily(node: N) {\n    const style = this.window.getComputedStyle(node);\n    return style.fontFamily || '';\n  }\n\n  /**\n   * @override\n   */\n  public nodeSize(node: N, em: number = 1, local: boolean = false) {\n    if (local && node.getBBox) {\n      let {width, height} = node.getBBox();\n      return [width / em , height / em] as [number, number];\n    }\n    return [node.offsetWidth / em, node.offsetHeight / em] as [number, number];\n  }\n\n  /**\n   * @override\n   */\n  public nodeBBox(node: N) {\n    const {left, right, top, bottom} = node.getBoundingClientRect() as PageBBox;\n    return {left, right, top, bottom};\n  }\n}\n","/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the browser DOM adaptor\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {HTMLAdaptor} from './HTMLAdaptor.js';\n\n//\n//  Let Typescript know about these\n//\ndeclare global {\n  interface Window {\n    Document: typeof Document;\n    DOMParser: typeof DOMParser;\n    XMLSerializer: typeof XMLSerializer;\n    HTMLElement: typeof HTMLElement;\n    HTMLCollection: typeof HTMLCollection;\n    NodeList: typeof NodeList;\n    DocumentFragment: typeof DocumentFragment;\n  }\n}\n\n/**\n * Function to create an HTML adpator for browsers\n *\n * @return {HTMLAdaptor}  The newly created adaptor\n */\nexport function browserAdaptor(): HTMLAdaptor<HTMLElement, Text, Document> {\n  return new HTMLAdaptor<HTMLElement, Text, Document>(window);\n}\n","/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  The DOMAdaptor interface and abstract class\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {OptionList} from '../util/Options.js';\n\n/**\n * The data for an attribute\n */\nexport type AttributeData = {\n  name: string,\n  value: string\n};\n\n/**\n * The data for an elements page-based bounding box\n */\nexport type PageBBox = {\n  left: number,\n  right: number,\n  top: number,\n  bottom: number\n};\n\n\n/*****************************************************************/\n/**\n *  The interface for the DOMAdaptor\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport interface DOMAdaptor<N, T, D> {\n  /**\n   * Document in which the nodes are to be created\n   */\n  document: D;\n\n  /**\n   * @param {string} text    The serialized document to be parsed\n   * @param {string} format  The format (e.g., 'text/html' or 'text/xhtml')\n   * @return {D}             The parsed document\n   */\n  parse(text: string, format?: string): D;\n\n  /**\n   * @param {string} kind      The tag name of the HTML node to be created\n   * @param {OptionList} def   The properties to set for the created node\n   * @param {(N|T)[]} children The child nodes for the created HTML node\n   * @param {string} ns        The namespace in which to create the node\n   * @return {N}               The generated HTML tree\n   */\n  node(kind: string, def?: OptionList, children?: (N | T)[], ns?: string): N;\n\n  /**\n   * @param {string} text   The text from which to create an HTML text node\n   * @return {T}            The generated text node with the given text\n   */\n  text(text: string): T;\n\n  /**\n   * @param {D} doc   The document whose head is to be obtained\n   * @return {N}      The document.head element\n   */\n  head(doc: D): N;\n\n  /**\n   * @param {D} doc   The document whose body is to be obtained\n   * @return {N}      The document.body element\n   */\n  body(doc: D): N;\n\n  /**\n   * @param {D} doc   The document whose documentElement is to be obtained\n   * @return {N}      The documentElement\n   */\n  root(doc: D): N;\n\n  /**\n   * @param {D} doc     The document whose doctype is to be obtained\n   * @return {string}   The DOCTYPE comment\n   */\n  doctype(doc: D): string;\n\n  /**\n   * @param {N} node        The node to search for tags\n   * @param {string} name   The name of the tag to search for\n   * @param {string} ns     The namespace to search in (or null for no namespace)\n   * @return {N[]}          The list of tags found\n   */\n  tags(node: N, name: string, ns?: string): N[];\n\n  /**\n   * Get a list of containers (to be searched for math).  These can be\n   *  specified by CSS selector, or as actual DOM elements or arrays of such.\n   *\n   * @param {(string | N | N[])[]} nodes  The array of items to make into a container list\n   * @param {D} document                  The document in which to search\n   * @return {N[]}                        The array of containers to search\n   */\n  getElements(nodes: (string | N | N[])[], document: D): N[];\n\n  /**\n   * Determine if a container node contains a given node somewhere in its DOM tree\n   *\n   * @param {N} container  The container to search\n   * @param {N|T} node     The node to look for\n   * @return {boolean}     True if the node is in the container's DOM tree\n   */\n  contains(container: N, node: N | T): boolean;\n\n  /**\n   * @param {N|T} node  The HTML node whose parent is to be obtained\n   * @return {N}        The parent node of the given one\n   */\n  parent(node: N | T): N;\n\n  /**\n   * @param {N} node     The HTML node to be appended to\n   * @param {N|T} child  The node or text to be appended\n   * @return {N|T}       The appended node\n   */\n  append(node: N, child: N | T): N | T;\n\n  /**\n   * @param {N|T} nchild  The node or text to be inserted\n   * @param {N|T} ochild  The node or text where the new child is to be added before it\n   */\n  insert(nchild: N | T, ochild: N | T): void;\n\n  /**\n   * @param {N|T} child  The node or text to be removed from its parent\n   * @return {N|T}       The removed node\n   */\n  remove(child: N | T): N | T;\n\n  /**\n   * @param {N|T} nnode  The node to replace with\n   * @param {N|T} onode  The child to be replaced\n   * @return {N|T}       The removed node\n   */\n  replace(nnode: N | T, onode: N | T): N | T;\n\n  /**\n   * @param {N} node   The HTML node to be cloned\n   * @return {N}       The copied node\n   */\n  clone(node: N): N;\n\n  /**\n   * @param {T} node    The HTML text node to be split\n   * @param {number} n  The index of the character where the split will occur\n   */\n  split(node: T, n: number): T;\n\n  /**\n   * @param {N|T} node   The HTML node whose sibling is to be obtained\n   * @return {N|T}       The node following the given one (or null)\n   */\n  next(node: N | T): N | T;\n\n  /**\n   * @param {N|T} node   The HTML node whose sibling is to be obtained\n   * @return {N|T}       The node preceding the given one (or null)\n   */\n  previous(node: N | T): N | T;\n\n  /**\n   * @param {N} node   The HTML node whose child is to be obtained\n   * @return {N|T}     The first child of the given node (or null)\n   */\n  firstChild(node: N): N | T;\n\n  /**\n   * @param {N} node   The HTML node whose child is to be obtained\n   * @return {N}       The last child of the given node (or null)\n   */\n  lastChild(node: N): N | T;\n\n  /**\n   * @param {N} node    The HTML node whose children are to be obtained\n   * @return {(N|T)[]}  Array of children for the given node (not a live list)\n   */\n  childNodes(node: N): (N | T)[];\n\n  /**\n   * @param {N} node    The HTML node whose child is to be obtained\n   * @param {number} i  The index of the child to return\n   * @return {N|T}      The i-th child node of the given node (or null)\n   */\n  childNode(node: N, i: number): N | T;\n\n  /**\n   * @param {N | T} node   The HTML node whose tag or node name is to be obtained\n   * @return {string}      The tag or node name of the given node\n   */\n  kind(node: N | T): string;\n\n  /**\n   * @param {N|T} node  The HTML node whose value is to be obtained\n   * @return {string}   The value of the given node\n   */\n  value(node: N | T): string;\n\n  /**\n   * @param {N} node    The HTML node whose text content is to be obtained\n   * @return {string}   The text content of the given node\n   */\n  textContent(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose inner HTML string is to be obtained\n   * @return {string}  The serialized content of the node\n   */\n  innerHTML(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose outer HTML string is to be obtained\n   * @return {string}  The serialized node and its content\n   */\n  outerHTML(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose serialized string is to be obtained\n   * @return {string}  The serialized node and its content\n   */\n  serializeXML(node: N): string;\n\n  /**\n   * @param {N} node               The HTML node whose attribute is to be set\n   * @param {string|number} name   The name of the attribute to set\n   * @param {string} value         The new value of the attribute\n   * @param {string=} ns           The namespace to use for the attribute\n   */\n  setAttribute(node: N, name: string, value: string | number, ns?: string): void;\n\n  /**\n   * @param {N} node           The HTML element whose attributes are to be set\n   * @param {OptionList} def   The attributes to set on that node\n   */\n  setAttributes(node: N, def: OptionList): void;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be obtained\n   * @param {string} name   The name of the attribute to get\n   * @return {string}       The value of the given attribute of the given node\n   */\n  getAttribute(node: N, name: string): string;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be removed\n   * @param {string} name   The name of the attribute to remove\n   */\n  removeAttribute(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be tested\n   * @param {string} name   The name of the attribute to test\n   * @return {boolean}      True of the node has the given attribute defined\n   */\n  hasAttribute(node: N, name: string): boolean;\n\n  /**\n   * @param {N} node           The HTML node whose attributes are to be returned\n   * @return {AttributeData[]} The list of attributes\n   */\n  allAttributes(node: N): AttributeData[];\n\n  /**\n   * @param {N} node        The HTML node whose class is to be augmented\n   * @param {string} name   The class to be added\n   */\n  addClass(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose class is to be changed\n   * @param {string} name   The class to be removed\n   */\n  removeClass(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose class is to be tested\n   * @param {string} name   The class to test\n   * @return {boolean}      True if the node has the given class\n   */\n  hasClass(node: N, name: string): boolean;\n\n  /**\n   * @param {N} node        The HTML node whose class list is needed\n   * @return {string[]}     An array of the class names for this node\n   */\n  allClasses(node: N): string[];\n\n  /**\n   * @param {N} node        The HTML node whose style is to be changed\n   * @param {string} name   The style to be set\n   * @param {string} value  The new value of the style\n   */\n  setStyle(node: N, name: string, value: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose style is to be obtained\n   * @param {string} name   The style to be obtained\n   * @return {string}       The value of the style\n   */\n  getStyle(node: N, name: string): string;\n\n  /**\n   * @param {N} node        The HTML node whose styles are to be returned\n   * @return {string}       The cssText for the styles\n   */\n  allStyles(node: N): string;\n\n  /**\n   * @param {N} node           The stylesheet node where the rule will be added\n   * @param {string[]} rules   The rule to add at the beginning of the stylesheet\n   */\n  insertRules(node: N, rules: string[]): void;\n\n  /**\n   * @param {N} node        The HTML node whose font size is to be determined\n   * @return {number}       The font size (in pixels) of the node\n   */\n  fontSize(node: N): number;\n\n  /**\n   * @param {N} node        The HTML node whose font family is to be determined\n   * @return {string}       The font family\n   */\n  fontFamily(node: N): string;\n\n  /**\n   * @param {N} node            The HTML node whose dimensions are to be determined\n   * @param {number} em         The number of pixels in an em\n   * @param {boolean} local     True if local coordinates are to be used in SVG elements\n   * @return {[number, number]} The width and height (in ems) of the element\n   */\n  nodeSize(node: N, em?: number, local?: boolean): [number, number];\n\n\n  /**\n   * @param {N} node            The HTML node whose BBox is to be determined\n   * @return {PageBBox}         BBox as {left, right, top, bottom} position on the page (in pixels)\n   */\n  nodeBBox(node: N): PageBBox;\n}\n\n/*****************************************************************/\n/**\n *  Abstract DOMAdaptor class for creating HTML elements\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport abstract class AbstractDOMAdaptor<N, T, D> implements DOMAdaptor<N, T, D> {\n\n  /**\n   * The document in which the HTML nodes will be created\n   */\n  public document: D;\n\n  /**\n   * @param {D} document  The document in which the nodes will be created\n   * @constructor\n   */\n  constructor(document: D = null) {\n    this.document = document;\n  }\n\n  /**\n   * @override\n   */\n  public abstract parse(text: string, format?: string): D;\n\n  /**\n   * @override\n   */\n  public node(kind: string, def: OptionList = {}, children: (N | T)[] = [], ns?: string) {\n    const node = this.create(kind, ns);\n    this.setAttributes(node, def);\n    for (const child of children) {\n      this.append(node, child);\n    }\n    return node as N;\n  }\n\n  /**\n   * @param {string} kind  The type of the node to create\n   * @param {string} ns    The optional namespace in which to create the node\n   * @return {N}           The created node\n   */\n  protected abstract create(kind: string, ns?: string): N;\n\n  /**\n   * @override\n   */\n  public abstract text(text: string): T;\n\n  /**\n   * @param {N} node           The HTML element whose attributes are to be set\n   * @param {OptionList} def   The attributes to set on that node\n   */\n  public setAttributes(node: N, def: OptionList) {\n    if (def.style && typeof(def.style) !== 'string') {\n      for (let key of Object.keys(def.style)) {\n        this.setStyle(node, key.replace(/-([a-z])/g, (_m, c) => c.toUpperCase()), def.style[key]);\n      }\n    }\n    if (def.properties) {\n      for (let key of Object.keys(def.properties)) {\n        (node as OptionList)[key] = def.properties[key];\n      }\n    }\n    for (let key of Object.keys(def)) {\n      if ((key !== 'style' || typeof(def.style) === 'string') && key !== 'properties') {\n        this.setAttribute(node, key, def[key]);\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  public abstract head(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract body(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract root(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract doctype(doc: D): string;\n\n  /**\n   * @override\n   */\n  public abstract tags(node: N, name: string, ns?: string): N[];\n\n  /**\n   * @override\n   */\n  public abstract getElements(nodes: (string | N | N[])[], document: D): N[];\n\n  /**\n   * @override\n   */\n  public abstract contains(container: N, node: N | T): boolean;\n\n  /**\n   * @override\n   */\n  public abstract parent(node: N | T): N;\n\n  /**\n   * @override\n   */\n  public abstract append(node: N, child: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract insert(nchild: N | T, ochild: N | T): void;\n\n  /**\n   * @override\n   */\n  public abstract remove(child: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public replace(nnode: N | T, onode: N | T) {\n    this.insert(nnode, onode);\n    this.remove(onode);\n    return onode;\n  }\n\n  /**\n   * @override\n   */\n  public abstract clone(node: N):  N;\n\n  /**\n   * @override\n   */\n  public abstract split(node: T, n: number): T;\n\n  /**\n   * @override\n   */\n  public abstract next(node: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract previous(node: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract firstChild(node: N): N | T;\n\n  /**\n   * @override\n   */\n  public abstract lastChild(node: N): N | T;\n\n  /**\n   * @override\n   */\n  public abstract childNodes(node: N): (N | T)[];\n\n  /**\n   * @override\n   */\n  public childNode(node: N, i: number) {\n    return this.childNodes(node)[i];\n  }\n\n  /**\n   * @override\n   */\n  public abstract kind(node: N | T): string;\n\n  /**\n   * @override\n   */\n  public abstract value(node: N | T): string;\n\n  /**\n   * @override\n   */\n  public abstract textContent(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract innerHTML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract outerHTML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract serializeXML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract setAttribute(node: N, name: string, value: string, ns?: string): void;\n\n  /**\n   * @override\n   */\n  public abstract getAttribute(node: N, name: string): string;\n\n  /**\n   * @override\n   */\n  public abstract removeAttribute(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract hasAttribute(node: N, name: string): boolean;\n\n\n  /**\n   * @override\n   */\n  public abstract allAttributes(node: N): AttributeData[];\n\n  /**\n   * @override\n   */\n  public abstract addClass(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract removeClass(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract hasClass(node: N, name: string): boolean;\n\n  /**\n   * @override\n   */\n  public allClasses(node: N) {\n    const classes = this.getAttribute(node, 'class');\n    return (!classes ? [] as string[] :\n            classes.replace(/  +/g, ' ').replace(/^ /, '').replace(/ $/, '').split(/ /));\n  }\n\n  /**\n   * @override\n   */\n  public abstract setStyle(node: N, name: string, value: string): void;\n\n  /**\n   * @override\n   */\n  public abstract getStyle(node: N, name: string): string;\n\n  /**\n   * @override\n   */\n  public abstract allStyles(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract insertRules(node: N, rules: string[]): void;\n\n  /**\n   * @override\n   */\n  public abstract fontSize(node: N): number;\n\n  /**\n   * @override\n   */\n  public abstract fontFamily(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract nodeSize(node: N, em?: number, local?: boolean): [number, number];\n\n  /**\n   * @override\n   */\n  public abstract nodeBBox(node: N): PageBBox;\n\n}\n"],"names":["window","document","parser","DOMParser","parse","text","format","this","parseFromString","create","kind","ns","createElementNS","createElement","createTextNode","head","doc","body","root","documentElement","doctype","name","tags","node","nodes","getElementsByTagNameNS","getElementsByTagName","Array","from","getElements","_document","containers","concat","querySelectorAll","isArray","NodeList","HTMLCollection","push","contains","container","parent","parentNode","append","child","appendChild","insert","nchild","ochild","insertBefore","remove","removeChild","replace","nnode","onode","replaceChild","clone","cloneNode","split","n","splitText","next","nextSibling","previous","previousSibling","firstChild","lastChild","childNodes","childNode","i","nodeType","nodeName","toLowerCase","value","nodeValue","textContent","innerHTML","outerHTML","serializeXML","XMLSerializer","serializeToString","setAttribute","setAttributeNS","getAttribute","removeAttribute","hasAttribute","allAttributes","attributes","map","x","addClass","classList","add","className","trim","removeClass","filter","c","join","hasClass","indexOf","setStyle","style","getStyle","allStyles","cssText","insertRules","rules","reverse","rule","sheet","insertRule","e","console","warn","message","fontSize","getComputedStyle","parseFloat","fontFamily","nodeSize","em","local","getBBox","offsetWidth","offsetHeight","nodeBBox","getBoundingClientRect","left","right","top","bottom","AbstractDOMAdaptor","HTMLAdaptor","def","children","setAttributes","Object","keys","key","_m","toUpperCase","properties","allClasses","classes"],"sourceRoot":""}