{"version":3,"file":"4066.nbdime.js","mappings":"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","sources":["webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/components/global.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/components/loader.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/components/package.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/require/RequireConfiguration.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Handles using MathJax global as config object, and to hold\n *                methods and data to be available to the page author\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {VERSION} from './version.js';\n\n/**\n * The MathJax variable as a configuration object\n */\nexport interface MathJaxConfig {\n  [name: string]: any;\n}\n\n/**\n * The object used to store class and other definitions\n * from the various MathJax modules so that they can be shared\n * among the various component webpack files\n */\nexport interface MathJaxLibrary {\n  [name: string]: any;\n}\n\n/**\n * The MathJax global object structure\n */\nexport interface MathJaxObject {\n  version: string;\n  _: MathJaxLibrary;\n  config: MathJaxConfig;\n}\n\ndeclare const global: {MathJax: MathJaxObject | MathJaxConfig};\n\n/**\n * @param {any} x     An item to test if it is an object\n * @return {boolean}  True if the item is a non-null object\n */\nexport function isObject(x: any): boolean {\n  return typeof x === 'object' && x !== null;\n}\n\n/**\n * Combine user-produced configuration with existing defaults.  Values\n * from src will replace those in dst.\n *\n * @param {any} dst      The destination config object (to be merged into)\n * @param {any} src      The source configuration object (to replace defaul values in dst}\n * @return {any}         The resulting (modified) config object\n */\nexport function combineConfig(dst: any, src: any): any {\n  for (const id of Object.keys(src)) {\n    if (id === '__esModule') continue;\n    if (isObject(dst[id]) && isObject(src[id]) &&\n        !(src[id] instanceof Promise) /* needed for IE polyfill */) {\n      combineConfig(dst[id], src[id]);\n    } else if (src[id] !== null && src[id] !== undefined) {\n      dst[id] = src[id];\n    }\n  }\n  return dst;\n}\n\n/**\n * Combine defaults into a configuration that may already have\n * user-provided values.  Values in src only go into dst if\n * there is not already a value for that key.\n *\n * @param {any} dst      The destination config object (to be merged into)\n * @param {string} name  The id of the configuration block to modify (created if doesn't exist)\n * @param {any} src      The source configuration object (to replace defaul values in dst}\n * @return {any}         The resulting (modified) config object\n */\nexport function combineDefaults(dst: any, name: string, src: any): any {\n  if (!dst[name]) {\n    dst[name] = {};\n  }\n  dst = dst[name];\n  for (const id of Object.keys(src)) {\n    if (isObject(dst[id]) && isObject(src[id])) {\n      combineDefaults(dst, id, src[id]);\n    } else if (dst[id] == null && src[id] != null) {\n      dst[id] = src[id];\n    }\n  }\n  return dst;\n}\n\n/**\n * Combine configuration or data with the existing MathJax object\n *\n * @param {any} config   The data to be merged into the MathJax object\n */\nexport function combineWithMathJax(config: any): MathJaxObject {\n  return combineConfig(MathJax, config);\n}\n\n\n/**\n * Create the MathJax global, if it doesn't exist\n */\nif (typeof global.MathJax === 'undefined') {\n  global.MathJax = {} as MathJaxConfig;\n}\n\n/**\n * If the global is currently a config object, convert it to the\n * MathJaxObject containing the version, class library, and user\n * configuration.\n */\nif (!(global.MathJax as MathJaxObject).version) {\n  global.MathJax = {\n    version: VERSION,\n    _: {},\n    config: global.MathJax\n  };\n}\n\n/**\n * Export the global MathJax object for convenience\n */\nexport const MathJax = global.MathJax as MathJaxObject;\n","/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  A dynamic loader for loading MathJax components based\n *                on a user configuration, while handling timing of\n *                dependencies properly\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {MathJax as MJGlobal, MathJaxObject as MJObject, MathJaxLibrary,\n        MathJaxConfig as MJConfig, combineWithMathJax, combineDefaults} from './global.js';\n\nimport {Package, PackageError, PackageReady, PackageFailed} from './package.js';\nexport {Package, PackageError, PackageReady, PackageFailed} from './package.js';\nexport {MathJaxLibrary} from './global.js';\n\nimport {FunctionList} from '../util/FunctionList.js';\n\n/*\n * The current directory (for webpack), and the browser document (if any)\n */\ndeclare var __dirname: string;\ndeclare var document: Document;\n\n/**\n * Function used to determine path to a given package.\n */\nexport type PathFilterFunction = (data: {name: string, original: string, addExtension: boolean}) => boolean;\nexport type PathFilterList = (PathFilterFunction | [PathFilterFunction, number])[];\n\n/**\n * Update the configuration structure to include the loader configuration\n */\nexport interface MathJaxConfig extends MJConfig {\n  loader?: {\n    paths?: {[name: string]: string};          // The path prefixes for use in locations\n    source?: {[name: string]: string};         // The URLs for the extensions, e.g., tex: [mathjax]/input/tex.js\n    dependencies?: {[name: string]: string[]}; // The dependencies for each package\n    provides?: {[name: string]: string[]};     // The sub-packages provided by each package\n    load?: string[];                           // The packages to load (found in locations or [mathjax]/name])\n    ready?: PackageReady;                      // A function to call when MathJax is ready\n    failed?: PackageFailed;                    // A function to call when MathJax fails to load\n    require?: (url: string) => any;            // A function for loading URLs\n    pathFilters?: PathFilterList;              // List of path filters (and optional priorities) to add\n    versionWarnings?: boolean;                 // True means warn when extension version doesn't match MJ version\n    [name: string]: any;                       // Other configuration blocks\n  };\n}\n\n/**\n * Update the MathJax object to inclide the loader information\n */\nexport interface MathJaxObject extends MJObject {\n  _: MathJaxLibrary;\n  config: MathJaxConfig;\n  loader: {\n    ready: (...names: string[]) => Promise<string[]>; // Get a promise for when all the named packages are loaded\n    load: (...names: string[]) => Promise<string>;    // Load the packages and return a promise for when ready\n    preLoad: (...names: string[]) => void;            // Indicate that packages are already loaded by hand\n    defaultReady: () => void;                         // The function performed when all packages are loaded\n    getRoot: () => string;                            // Find the root URL for the MathJax files\n    checkVersion: (name: string, version: string) => boolean;   // Check the version of an extension\n    pathFilters: FunctionList;                        // the filters to use for looking for package paths\n  };\n  startup?: any;\n}\n\n/**\n * Functions used to filter the path to a package\n */\nexport const PathFilters: {[name: string]: PathFilterFunction} = {\n  /**\n   * Look up the path in the configuration's source list\n   */\n  source: (data) => {\n    if (CONFIG.source.hasOwnProperty(data.name)) {\n      data.name = CONFIG.source[data.name];\n    }\n    return true;\n  },\n\n  /**\n   * Add [mathjax] before any relative path, and add .js if needed\n   */\n  normalize: (data) => {\n    const name = data.name;\n    if (!name.match(/^(?:[a-z]+:\\/)?\\/|[a-z]:\\\\|\\[/i)) {\n      data.name = '[mathjax]/' + name.replace(/^\\.\\//, '');\n    }\n    if (data.addExtension && !name.match(/\\.[^\\/]+$/)) {\n      data.name += '.js';\n    }\n    return true;\n  },\n\n  /**\n   * Recursively replace path prefixes (e.g., [mathjax], [tex], etc.)\n   */\n  prefix: (data) => {\n    let match;\n    while ((match = data.name.match(/^\\[([^\\]]*)\\]/))) {\n      if (!CONFIG.paths.hasOwnProperty(match[1])) break;\n      data.name = CONFIG.paths[match[1]] + data.name.substr(match[0].length);\n    }\n    return true;\n  }\n\n};\n\n\n/**\n * The implementation of the dynamic loader\n */\nexport namespace Loader {\n\n  /**\n   * The version of MathJax that is running.\n   */\n  const VERSION = MJGlobal.version;\n\n  /**\n   * The versions of all the loaded extensions.\n   */\n  export const versions: Map<string, string> = new Map();\n\n  /**\n   * Get a promise that is resolved when all the named packages have been loaded.\n   *\n   * @param {string[]} names  The packages to wait for\n   * @returns {Promise}       A promise that resolves when all the named packages are ready\n   */\n  export function ready(...names: string[]): Promise<string[]> {\n    if (names.length === 0) {\n      names = Array.from(Package.packages.keys());\n    }\n    const promises = [];\n    for (const name of names) {\n      const extension = Package.packages.get(name) || new Package(name, true);\n      promises.push(extension.promise);\n    }\n    return Promise.all(promises);\n  }\n\n  /**\n   * Load the named packages and return a promise that is resolved when they are all loaded\n   *\n   * @param {string[]} names  The packages to load\n   * @returns {Promise}       A promise that resolves when all the named packages are ready\n   */\n  export function load(...names: string[]): Promise<void | string[]> {\n    if (names.length === 0) {\n      return Promise.resolve();\n    }\n    const promises = [];\n    for (const name of names) {\n      let extension = Package.packages.get(name);\n      if (!extension) {\n        extension = new Package(name);\n        extension.provides(CONFIG.provides[name]);\n      }\n      extension.checkNoLoad();\n      promises.push(extension.promise.then(() => {\n        if (!CONFIG.versionWarnings) return;\n        if (extension.isLoaded && !versions.has(Package.resolvePath(name))) {\n          console.warn(`No version information available for component ${name}`);\n        }\n      }) as Promise<null>);\n    }\n    Package.loadAll();\n    return Promise.all(promises);\n  }\n\n  /**\n   * Indicate that the named packages are being loaded by hand (e.g., as part of a larger package).\n   *\n   * @param {string[]} names  The packages to load\n   */\n  export function preLoad(...names: string[]) {\n    for (const name of names) {\n      let extension = Package.packages.get(name);\n      if (!extension) {\n        extension = new Package(name, true);\n        extension.provides(CONFIG.provides[name]);\n      }\n      extension.loaded();\n    }\n  }\n\n  /**\n   * The default function to perform when all the packages are loaded\n   */\n  export function defaultReady() {\n    if (typeof MathJax.startup !== 'undefined') {\n      MathJax.config.startup.ready();\n    }\n  }\n\n  /**\n   * Get the root location for where the MathJax package files are found\n   *\n   * @returns {string}   The root location (directory for node.js, URL for browser)\n   */\n  export function getRoot(): string {\n    let root = __dirname + '/../../es5';\n    if (typeof document !== 'undefined') {\n      const script = document.currentScript || document.getElementById('MathJax-script');\n      if (script) {\n        root = (script as HTMLScriptElement).src.replace(/\\/[^\\/]*$/, '');\n      }\n    }\n    return root;\n  }\n\n  /**\n   * Check the version of an extension and report an error if not correct\n   *\n   * @param {string} name       The name of the extension being checked\n   * @param {string} version    The version of the extension to check\n   * @param {string} type       The type of extension (future code may use this to check ranges of versions)\n   * @return {boolean}          True if there was a mismatch, false otherwise\n   */\n  export function checkVersion(name: string, version: string, _type?: string): boolean {\n    versions.set(Package.resolvePath(name), VERSION);\n    if (CONFIG.versionWarnings && version !== VERSION) {\n      console.warn(`Component ${name} uses ${version} of MathJax; version in use is ${VERSION}`);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * The filters to use to modify the paths used to obtain the packages\n   */\n  export const pathFilters = new FunctionList();\n\n  /**\n   * The default filters to use.\n   */\n  pathFilters.add(PathFilters.source, 0);\n  pathFilters.add(PathFilters.normalize, 10);\n  pathFilters.add(PathFilters.prefix, 20);\n}\n\n/**\n * Export the global MathJax object for convenience\n */\nexport const MathJax = MJGlobal as MathJaxObject;\n\n/*\n * If the loader hasn't been added to the MathJax variable,\n *   Add the loader configuration, library, and data objects.\n *   Add any path filters from the configuration.\n */\nif (typeof MathJax.loader === 'undefined') {\n\n  combineDefaults(MathJax.config, 'loader', {\n    paths: {\n      mathjax: Loader.getRoot()\n    },\n    source: {},\n    dependencies: {},\n    provides: {},\n    load: [],\n    ready: Loader.defaultReady.bind(Loader),\n    failed: (error: PackageError) => console.log(`MathJax(${error.package || '?'}): ${error.message}`),\n    require: null,\n    pathFilters: [],\n    versionWarnings: true\n  });\n  combineWithMathJax({\n    loader: Loader\n  });\n\n  //\n  // Add any path filters from the configuration\n  //\n  for (const filter of MathJax.config.loader.pathFilters) {\n    if (Array.isArray(filter)) {\n      Loader.pathFilters.add(filter[0], filter[1]);\n    } else {\n      Loader.pathFilters.add(filter);\n    }\n  }\n}\n\n/**\n * Export the loader configuration for convenience\n */\nexport const CONFIG = MathJax.config.loader;\n","/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements component Package object for handling\n *                dynamic loading of components.\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {CONFIG, Loader} from './loader.js';\n\n/*\n * The browser document (for creating scripts to load components)\n */\ndeclare var document: Document;\n\n/**\n * A map of package names to Package instances\n */\nexport type PackageMap = Map<string, Package>;\n\n/**\n * An error class that includes the package name\n */\nexport class PackageError extends Error {\n  /* tslint:disable:jsdoc-require */\n  public package: string;\n  constructor(message: string, name: string) {\n    super(message);\n    this.package = name;\n  }\n  /* tslint:enable */\n}\n\n/**\n * Types for ready() and failed() functions and for promises\n */\nexport type PackageReady = (name: string) => string | void;\nexport type PackageFailed = (message: PackageError) => void;\nexport type PackagePromise = (resolve: PackageReady, reject: PackageFailed) => void;\n\n/**\n * The configuration data for a package\n */\nexport interface PackageConfig {\n  ready?: PackageReady;                // Function to call when package is loaded successfully\n  failed?: PackageFailed;              // Function to call when package fails to load\n  checkReady?: () => Promise<void>;    // Function called to see if package is fully loaded\n                                       //   (may cause additional packages to load, for example)\n}\n\n/**\n * The Package class for handling individual components\n */\nexport class Package {\n  /**\n   * The set of packages being used\n   */\n  public static packages: PackageMap = new Map();\n\n  /**\n   * The package name\n   */\n  public name: string;\n\n  /**\n   * True when the package has been loaded successfully\n   */\n  public isLoaded: boolean = false;\n\n  /**\n   * A promise that resolves when the package is loaded successfully and rejects when it fails to load\n   */\n  public promise: Promise<string>;\n\n  /**\n   * True when the package is being loaded but hasn't yet finished loading\n   */\n  protected isLoading: boolean = false;\n\n  /**\n   * True if the package has failed to load\n   */\n  protected hasFailed: boolean = false;\n\n  /**\n   * True if this package should be loaded automatically (e.g., it was created in reference\n   *   to a MathJax.loader.ready() call when the package hasn't been requested to load)\n   */\n  protected noLoad: boolean;\n\n  /**\n   * The function that resolves the package's promise\n   */\n  protected resolve: PackageReady;\n\n  /**\n   * The function that rejects the package's promise\n   */\n  protected reject: PackageFailed;\n\n  /**\n   * The packages that require this one\n   */\n  protected dependents: Package[] = [];\n\n  /**\n   * The packages that this one depends on\n   */\n  protected dependencies: Package[] = [];\n\n  /**\n   * The number of dependencies that haven't yet been loaded\n   */\n  protected dependencyCount: number = 0;\n\n  /**\n   * The sub-packages that this one provides\n   */\n  protected provided: Package[] = [];\n\n  /**\n   * @return {boolean}  True when the package can be loaded (i.e., its dependencies are all loaded,\n   *                    it is allowed to be loaded, isn't already loading, and hasn't failed to load\n   *                    in the past)\n   */\n  get canLoad(): boolean {\n    return this.dependencyCount === 0 && !this.noLoad && !this.isLoading && !this.hasFailed;\n  }\n\n  /**\n   * Compute the path for a package using the loader's path filters\n   *\n   * @param {string} name            The name of the package to resolve\n   * @param {boolean} addExtension   True if .js should be added automatically\n   * @return {string}                The path (file or URL) for this package\n   */\n  public static resolvePath(name: string, addExtension: boolean = true): string {\n    const data = {name, original: name, addExtension};\n    Loader.pathFilters.execute(data);\n    return data.name;\n  }\n\n  /**\n   * Attempt to load all packages that are ready to be loaded\n   * (i.e., that have no unloaded dependencies, and that haven't\n   *  already been loaded, and that aren't in process of being\n   *  loaded, and that aren't marked as noLoad).\n   */\n  public static loadAll() {\n    for (const extension of this.packages.values()) {\n      if (extension.canLoad) {\n        extension.load();\n      }\n    }\n  }\n\n  /**\n   * @param {string} name        The name of the package\n   * @param {boolean} noLoad     True when the package is just for reference, not loading\n   */\n  constructor(name: string, noLoad: boolean = false) {\n    this.name = name;\n    this.noLoad = noLoad;\n    Package.packages.set(name, this);\n    this.promise = this.makePromise(this.makeDependencies());\n  }\n\n  /**\n   * @return {Promise<string>[]}   The array of promises that must be resolved before this package\n   *                                 can be loaded\n   */\n  protected makeDependencies(): Promise<string>[] {\n    const promises = [] as Promise<string>[];\n    const map = Package.packages;\n    const noLoad = this.noLoad;\n    const name = this.name;\n    //\n    //  Get the dependencies for this package\n    //\n    const dependencies = [] as string[];\n    if (CONFIG.dependencies.hasOwnProperty(name)) {\n      dependencies.push(...CONFIG.dependencies[name]);\n    } else if (name !== 'core') {\n      dependencies.push('core');  //  Add 'core' dependency by default\n    }\n    //\n    //  Add all the dependencies (creating them, if needed)\n    //    and record the promises of unloaded ones\n    //\n    for (const dependent of dependencies) {\n      const extension = map.get(dependent) || new Package(dependent, noLoad);\n      if (this.dependencies.indexOf(extension) < 0) {\n        extension.addDependent(this, noLoad);\n        this.dependencies.push(extension);\n        if (!extension.isLoaded) {\n          this.dependencyCount++;\n          promises.push(extension.promise);\n        }\n      }\n    }\n    //\n    //  Return the collected promises\n    //\n    return promises;\n  }\n\n  /**\n   * @param {Promise<string>[]} promises  The array or promises that must be resolved before\n   *                                        this package can load\n   */\n  protected makePromise(promises: Promise<string>[]) {\n    //\n    //  Make a promise and save its resolve/reject functions\n    //\n    let promise = new Promise<string>(((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    }) as PackagePromise);\n    //\n    //  If there is a ready() function in the configuration for this package,\n    //    Add running that to the promise\n    //\n    const config = (CONFIG[this.name] || {}) as PackageConfig;\n    if (config.ready) {\n      promise = promise.then((_name: string) => config.ready(this.name)) as Promise<string>;\n    }\n    //\n    //  If there are promises for dependencies,\n    //    Add the one for loading this package and create a promise for all of them\n    //      (That way, if any of them fail to load, our promise will reject automatically)\n    //\n    if (promises.length) {\n      promises.push(promise);\n      promise = Promise.all(promises).then((names: string[]) => names.join(', '));\n    }\n    //\n    //  If there is a failed() function in the configuration for this package,\n    //    Add a catch to handle the error\n    //\n    if (config.failed) {\n      promise.catch((message: string) => config.failed(new PackageError(message, this.name)));\n    }\n    //\n    //  Return the promise that represents when this file is loaded\n    //\n    return promise;\n  }\n\n  /**\n   * Attempt to load this package\n   */\n  public load() {\n    if (!this.isLoaded && !this.isLoading && !this.noLoad) {\n      this.isLoading = true;\n      const url = Package.resolvePath(this.name);\n      if (CONFIG.require) {\n        this.loadCustom(url);\n      } else {\n        this.loadScript(url);\n      }\n    }\n  }\n\n  /**\n   * Load using a custom require method (usually the one from node.js)\n   */\n  protected loadCustom(url: string) {\n    try {\n      const result = CONFIG.require(url);\n      if (result instanceof Promise) {\n        result.then(() => this.checkLoad())\n          .catch((err) => this.failed('Can\\'t load \"' + url + '\"\\n' + err.message.trim()));\n      } else {\n        this.checkLoad();\n      }\n    } catch (err) {\n      this.failed(err.message);\n    }\n  }\n\n  /**\n   * Load in a browser by inserting a script to load the proper URL\n   */\n  protected loadScript(url: string) {\n    const script = document.createElement('script');\n    script.src = url;\n    script.charset = 'UTF-8';\n    script.onload = (_event) => this.checkLoad();\n    script.onerror = (_event) => this.failed('Can\\'t load \"' + url + '\"');\n    // FIXME: Should there be a timeout failure as well?\n    document.head.appendChild(script);\n  }\n\n  /**\n   * Called when the package is loaded.\n   *\n   * Mark it as loaded, and tell its dependents that this package\n   *   has been loaded (may cause dependents to load themselves).\n   *   Mark any provided packages as loaded.\n   * Resolve the promise that says this package is loaded.\n   */\n  public loaded() {\n    this.isLoaded = true;\n    this.isLoading = false;\n    for (const dependent of this.dependents) {\n      dependent.requirementSatisfied();\n    }\n    for (const provided of this.provided) {\n      provided.loaded();\n    }\n    this.resolve(this.name);\n  }\n\n  /**\n   * Called when the package fails to load for some reason\n   *\n   * Mark it as failed to load\n   * Reject the promise for this package with an error\n   *\n   * @param {string} message   The error message for a load failure\n   */\n  protected failed(message: string) {\n    this.hasFailed = true;\n    this.isLoading = false;\n    this.reject(new PackageError(message, this.name));\n  }\n\n  /**\n   * Check if a package is really ready to be marked as loaded\n   * (When it is loaded, it may set its own checkReady() function\n   *  as a means of loading additional packages.  E.g., an output\n   *  jax may load a font package, dependent on its configuration.)\n   *\n   *  The configuration's checkReady() function returns a promise\n   *  that allows the loader to wait for addition actions to finish\n   *  before marking the file as loaded (or failing to load).\n   */\n  protected checkLoad() {\n    const config = (CONFIG[this.name] || {}) as PackageConfig;\n    const checkReady = config.checkReady || (() => Promise.resolve());\n    checkReady().then(() => this.loaded())\n      .catch((message) => this.failed(message));\n  }\n\n  /**\n   * This is called when a dependency loads.\n   *\n   * Decrease the dependency count, and try to load this package\n   * when the dependencies are all loaded.\n   */\n  public requirementSatisfied() {\n    if (this.dependencyCount) {\n      this.dependencyCount--;\n      if (this.canLoad) {\n        this.load();\n      }\n    }\n  }\n\n  /**\n   * @param {string[]} names    The names of the packages that this package provides\n   */\n  public provides(names: string[] = []) {\n    for (const name of names) {\n      let provided = Package.packages.get(name);\n      if (!provided) {\n        if (!CONFIG.dependencies[name]) {\n          CONFIG.dependencies[name] = [];\n        }\n        CONFIG.dependencies[name].push(name);\n        provided = new Package(name, true);\n        provided.isLoading = true;\n      }\n      this.provided.push(provided);\n    }\n  }\n\n  /**\n   * Add a package as a dependent, and if it is not just for reference,\n   *   check if we need to change our noLoad status.\n   *\n   * @param {Package} extension   The package to add as a dependent\n   * @param {boolean} noLoad      The noLoad status of the dependent\n   */\n  public addDependent(extension: Package, noLoad: boolean) {\n    this.dependents.push(extension);\n    if (!noLoad) {\n      this.checkNoLoad();\n    }\n  }\n\n  /**\n   * If this package is marked as noLoad, change that and check all\n   *   our dependencies to see if they need to change their noLoad\n   *   status as well.\n   *\n   *  I.e., if there are dependencies that were set up for reference\n   *  and a leaf node needs to be loaded, make sure all parent nodes\n   *  are marked as needing to be loaded as well.\n   */\n  public checkNoLoad() {\n    if (this.noLoad) {\n      this.noLoad = false;\n      for (const dependency of this.dependencies) {\n        dependency.checkNoLoad();\n      }\n    }\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2019-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview    Configuration file for the require package.\n *\n * @author dpvc@mathjax.org (Davide P. Cervone)\n */\n\nimport {Configuration, ParserConfiguration, ConfigurationHandler} from '../Configuration.js';\nimport TexParser from '../TexParser.js';\nimport {CommandMap} from '../SymbolMap.js';\nimport {ParseMethod} from '../Types.js';\nimport TexError from '../TexError.js';\nimport {TeX} from '../../tex.js';\n\nimport {MathJax} from '../../../components/global.js';\nimport {Package} from '../../../components/package.js';\nimport {Loader, CONFIG as LOADERCONFIG} from '../../../components/loader.js';\nimport {mathjax} from '../../../mathjax.js';\nimport {expandable} from '../../../util/Options.js';\n\n/**\n * The MathJax configuration block (for looking up user-defined package options)\n */\nconst MJCONFIG = MathJax.config;\n\n/**\n * Add an extension to the configuration, and configure its user options\n *\n * @param {TeX} jax       The TeX jax whose configuration is to be modified\n * @param {string} name   The name of the extension being added (e.g., '[tex]/amscd')\n */\nfunction RegisterExtension(jax: TeX<any, any, any>, name: string) {\n  const require = jax.parseOptions.options.require;\n  const required = jax.parseOptions.packageData.get('require').required as string[];\n  const extension = name.substr(require.prefix.length);\n  if (required.indexOf(extension) < 0) {\n    required.push(extension);\n    //\n    //  Register any dependencies that were loaded to handle this one\n    //\n    RegisterDependencies(jax, LOADERCONFIG.dependencies[name]);\n    //\n    //  If the required file loaded an extension...\n    //\n    const handler = ConfigurationHandler.get(extension);\n    if (handler) {\n      //\n      //  Check if there are user-supplied options\n      //    (place them in a block for the extension, if needed)\n      //\n      let options = MJCONFIG[name] || {};\n      if (handler.options && Object.keys(handler.options).length === 1 && handler.options[extension]) {\n        options = {[extension]: options};\n      }\n      //\n      //  Register the extension with the jax's configuration\n      //\n      (jax as any).configuration.add(extension, jax, options);\n      //\n      // If there are preprocessors, restart so that they run\n      // (we don't have access to the document or MathItem needed to call\n      //  the preprocessors from here)\n      //\n      const configured = jax.parseOptions.packageData.get('require').configured;\n      if (handler.preprocessors.length && !configured.has(extension)) {\n        configured.set(extension, true);\n        mathjax.retryAfter(Promise.resolve());\n      }\n    }\n  }\n}\n\n/**\n * Register any dependencies for the loaded extension\n *\n * @param {TeX} jax          The jax whose configuration is being modified\n * @param {string[]} names   The names of the dependencies to register\n */\nfunction RegisterDependencies(jax: TeX<any, any, any>, names: string[] = []) {\n  const prefix = jax.parseOptions.options.require.prefix;\n  for (const name of names) {\n    if (name.substr(0, prefix.length) === prefix) {\n      RegisterExtension(jax, name);\n    }\n  }\n}\n\n/**\n * Load a required package\n *\n * @param {TexParser} parser   The current tex parser.\n * @param {string} name        The name of the package to load.\n */\nexport function RequireLoad(parser: TexParser, name: string) {\n  const options = parser.options.require;\n  const allow = options.allow;\n  const extension = (name.substr(0, 1) === '[' ? '' : options.prefix) + name;\n  const allowed = (allow.hasOwnProperty(extension) ? allow[extension] :\n                   allow.hasOwnProperty(name) ? allow[name] : options.defaultAllow);\n  if (!allowed) {\n    throw new TexError('BadRequire', 'Extension \"%1\" is not allowed to be loaded', extension);\n  }\n  if (Package.packages.has(extension)) {\n    RegisterExtension(parser.configuration.packageData.get('require').jax, extension);\n  } else {\n    mathjax.retryAfter(Loader.load(extension));\n  }\n}\n\n/**\n * Save the jax so that it can be used when \\require{} is processed.\n */\nfunction config(_config: ParserConfiguration, jax: TeX<any, any, any>) {\n  jax.parseOptions.packageData.set('require', {\n    jax: jax,                             // \\require needs access to this\n    required: [...jax.options.packages],  // stores the names of the packages that have been added\n    configured: new Map()                 // stores the packages that have been configured\n  });\n  const options = jax.parseOptions.options.require;\n  const prefix = options.prefix;\n  if (prefix.match(/[^_a-zA-Z0-9]/)) {\n    throw Error('Illegal characters used in \\\\require prefix');\n  }\n  if (!LOADERCONFIG.paths[prefix]) {\n    LOADERCONFIG.paths[prefix] = '[mathjax]/input/tex/extensions';\n  }\n  options.prefix = '[' + prefix + ']/';\n}\n\n\n/**\n * Namespace for \\require methods\n */\nexport const RequireMethods: Record<string, ParseMethod> = {\n\n  /**\n   * Implements \\require macro to load TeX extensions\n   *\n   * @param {TexParser} parser   The current tex parser.\n   * @param {string} name        The name of the calling macro.\n   */\n  Require(parser: TexParser, name: string) {\n    const required = parser.GetArgument(name);\n    if (required.match(/[^_a-zA-Z0-9]/) || required === '') {\n      throw new TexError('BadPackageName', 'Argument for %1 is not a valid package name', name);\n    }\n    RequireLoad(parser, required);\n  }\n\n};\n\n/**\n * The options for the require extension\n */\nexport const options = {\n  require: {\n    //\n    // Specifies which extensions can/can't be required.\n    // The keys are the names of extensions, and the value is true\n    //   if the extension can be required, and false if it can't\n    //\n    allow: expandable({\n      base: false,\n      'all-packages': false,\n      autoload: false,\n      configmacros: false,\n      tagformat: false,\n      setoptions: false\n    }),\n    //\n    //  The default allow value if the extension isn't in the list above\n    //\n    defaultAllow: true,\n    //\n    //  The path prefix to use for exensions:  'tex' means use '[tex]/'\n    //  before the extension name.\n    //\n    prefix: 'tex'\n  }\n};\n\n/**\n * The command map for the \\require macro\n */\nnew CommandMap('require', {require: 'Require'}, RequireMethods);\n\n/**\n * The configuration for the \\require macro\n */\nexport const RequireConfiguration = Configuration.create(\n  'require', {handler: {macro: ['require']}, config, options}\n);\n"],"names":["isObject","x","combineConfig","dst","src","Object","keys","id","Promise","undefined","combineDefaults","name","config","MathJax","g","version","VERSION","_","Package","PackageError","Loader","PathFilters","source","data","CONFIG","hasOwnProperty","normalize","match","replace","addExtension","prefix","paths","substr","length","versions","Map","ready","names","Array","from","packages","promises","extension","get","push","promise","all","load","resolve","provides","checkNoLoad","then","versionWarnings","isLoaded","has","resolvePath","console","warn","loadAll","preLoad","loaded","defaultReady","startup","getRoot","root","__dirname","document","script","currentScript","getElementById","checkVersion","_type","set","pathFilters","FunctionList","add","loader","mathjax","dependencies","bind","failed","error","log","package","message","require","combineWithMathJax","filter","isArray","Error","noLoad","isLoading","hasFailed","dependents","dependencyCount","provided","this","makePromise","makeDependencies","original","execute","values","canLoad","map","dependent","indexOf","addDependent","reject","_name","join","catch","url","loadCustom","loadScript","result","checkLoad","err","trim","createElement","charset","onload","_event","onerror","head","appendChild","requirementSatisfied","checkReady","MJCONFIG","RegisterExtension","jax","parseOptions","options","required","packageData","RegisterDependencies","handler","ConfigurationHandler","configuration","configured","preprocessors","retryAfter","RequireLoad","parser","allow","defaultAllow","RequireMethods","Require","GetArgument","expandable","base","autoload","configmacros","tagformat","setoptions","CommandMap","RequireConfiguration","Configuration","create","macro","_config"],"sourceRoot":""}