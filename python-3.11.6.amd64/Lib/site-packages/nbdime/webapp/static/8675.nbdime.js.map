{"version":3,"file":"8675.nbdime.js","mappings":"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","sources":["webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/components/version.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/core/HandlerList.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/Configuration.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/MapHandler.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/NodeUtil.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/ParseUtil.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/Stack.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/Symbol.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/SymbolMap.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/Tags.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/TexError.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/TexParser.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/mathjax.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/util/AsyncLoad.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/util/Entities.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/util/FunctionList.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/util/PrioritizedList.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/util/Retries.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  The version of MathJax (used to tell what version a component\n *                was compiled against).\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nexport const VERSION = '3.2.2';\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the interface and abstract class for HandlerList objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {PrioritizedList} from '../util/PrioritizedList.js';\nimport {OptionList} from '../util/Options.js';\nimport {Handler} from './Handler.js';\nimport {MathDocument} from './MathDocument.js';\n\n/*****************************************************************/\n/**\n *  The HandlerList class (extends PrioritizedList of Handlers)\n *\n *  This list is used to find the handler for a given document\n *  by asking each handler to test if it can handle the document,\n *  and when one can, it is asked to create its associated MathDocument.\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport class HandlerList<N, T, D> extends PrioritizedList<Handler<N, T, D>>  {\n\n  /**\n   * @param {Handler} handler  The handler to register\n   * @return {Handler}  The list item created for the handler\n   */\n  public register(handler: Handler<N, T, D>): Handler<N, T, D> {\n    return this.add(handler, handler.priority);\n  }\n\n  /**\n   * @param {Handler} Handler  The handler to remove from the list\n   */\n  public unregister(handler: Handler<N, T, D>) {\n    this.remove(handler);\n  }\n\n  /**\n   * @param {any} document  The document (string, window, DOM element, etc) to be handled\n   * @return {Handler}      The handler from the list that can process the given document\n   */\n  public handlesDocument(document: any): Handler<N, T, D> {\n    for (const item of this) {\n      let handler = item.item;\n      if (handler.handlesDocument(document)) {\n        return handler;\n      }\n    }\n    throw new Error(`Can't find handler for document`);\n  }\n\n  /**\n   * @param {any} document        The document to be processed\n   * @param {OptionList} options  The options for the handler\n   * @return {MathDocument}       The MathDocument created by the handler for this document\n   */\n  public document(document: any, options: OptionList = null): MathDocument<N, T, D> {\n    return this.handlesDocument(document).create(document, options);\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Configuration options for the TexParser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {HandlerConfig, FallbackConfig} from './MapHandler.js';\nimport {StackItemClass} from './StackItem.js';\nimport {TagsClass} from './Tags.js';\nimport {userOptions, defaultOptions, OptionList} from '../../util/Options.js';\nimport {SubHandlers} from './MapHandler.js';\nimport {FunctionList} from '../../util/FunctionList.js';\nimport {TeX} from '../tex.js';\nimport {PrioritizedList} from '../../util/PrioritizedList.js';\nimport {TagsFactory} from './Tags.js';\n\n\nexport type StackItemConfig = {[kind: string]: StackItemClass};\nexport type TagsConfig = {[kind: string]: TagsClass};\nexport type Processor<T> = [T, number];\nexport type ProtoProcessor<T> = Processor<T> | T;\nexport type ProcessorList = Processor<Function>[];\nexport type ConfigMethod = (c: ParserConfiguration, j: TeX<any, any, any>) => void;\nexport type InitMethod = (c: ParserConfiguration) => void;\n\n\n\nexport class Configuration {\n\n  /**\n   * Creates a function priority pair.\n   * @param {ProtoProcessor<T>} func The function or processor.\n   * @param {number} priority The default priority.\n   * @return {Processor} The processor pair.\n   * @template T\n   */\n  private static makeProcessor<T>(func: ProtoProcessor<T>, priority: number): Processor<T> {\n    return Array.isArray(func) ? func : [func, priority];\n  }\n\n  /**\n   * Creates a configuration for a package.\n   * @param {string} name The package name or empty string.\n   * @param {Object} config See `create` method.\n   * @return {Configuration} The newly generated configuration.\n   */\n  private static _create(name: string,\n                         config: {handler?: HandlerConfig,\n                                  fallback?: FallbackConfig,\n                                  items?: StackItemConfig,\n                                  tags?: TagsConfig,\n                                  options?: OptionList,\n                                  nodes?: {[key: string]: any},\n                                  preprocessors?: ProtoProcessor<Function>[],\n                                  postprocessors?: ProtoProcessor<Function>[],\n                                  init?: ProtoProcessor<InitMethod>,\n                                  config?: ProtoProcessor<ConfigMethod>,\n                                  priority?: number,\n                                  parser?: string,\n                                 } = {}): Configuration {\n    let priority = config.priority || PrioritizedList.DEFAULTPRIORITY;\n    let init = config.init ? this.makeProcessor(config.init, priority) : null;\n    let conf = config.config ? this.makeProcessor(config.config, priority) : null;\n    let preprocessors = (config.preprocessors || []).map(\n      pre => this.makeProcessor(pre, priority));\n    let postprocessors = (config.postprocessors || []).map(\n      post => this.makeProcessor(post, priority));\n    let parser = config.parser || 'tex';\n    return new Configuration(\n      name,\n      config.handler || {},\n      config.fallback || {},\n      config.items || {},\n      config.tags || {},\n      config.options || {},\n      config.nodes || {},\n      preprocessors, postprocessors, init, conf, priority,\n      parser\n    );\n  }\n\n  /**\n   * Creator pattern for creating a named package configuration. This will be\n   * administered in the configuration handler and can be retrieved again.\n   * @param {string} name The package name.\n   * @param {Object} config The configuration parameters:\n   * Configuration for the TexParser consist of the following:\n   *  * _handler_  configuration mapping handler types to lists of symbol mappings.\n   *  * _fallback_ configuration mapping handler types to fallback methods.\n   *  * _items_ for the StackItem factory.\n   *  * _tags_ mapping tagging configurations to tagging objects.\n   *  * _options_ parse options for the packages.\n   *  * _nodes_ for the Node factory.\n   *  * _preprocessors_ list of functions for preprocessing the LaTeX\n   *      string wrt. to given parse options. Can contain a priority.\n   *  * _postprocessors_ list of functions for postprocessing the MmlNode\n   *      wrt. to given parse options. Can contain a priority.\n   *  * _init_ init method and optionally its priority.\n   *  * _config_ config method and optionally its priority.\n   *  * _priority_ default priority of the configuration.\n   *  * _parser_ the name of the parser that this configuration targets.\n   * @return {Configuration} The newly generated configuration.\n   */\n  public static create(name: string,\n                       config: {handler?: HandlerConfig,\n                                fallback?: FallbackConfig,\n                                items?: StackItemConfig,\n                                tags?: TagsConfig,\n                                options?: OptionList,\n                                nodes?: {[key: string]: any},\n                                preprocessors?: ProtoProcessor<Function>[],\n                                postprocessors?: ProtoProcessor<Function>[],\n                                init?: ProtoProcessor<InitMethod>,\n                                config?: ProtoProcessor<ConfigMethod>,\n                                priority?: number,\n                                parser?: string,\n                               } = {}): Configuration {\n    let configuration = Configuration._create(name, config);\n    ConfigurationHandler.set(name, configuration);\n    return configuration;\n  }\n\n  /**\n   * Creates an unnamed, ephemeral package configuration. It will not added to\n   * the configuration handler.\n   * @param {Object} config See `create` method.\n   * @return {Configuration} The ephemeral package configuration.\n   */\n  public static local(config: {handler?: HandlerConfig,\n                              fallback?: FallbackConfig,\n                              items?: StackItemConfig,\n                              tags?: TagsConfig,\n                              options?: OptionList,\n                              nodes?: {[key: string]: any},\n                              preprocessors?: ProtoProcessor<Function>[],\n                              postprocessors?: ProtoProcessor<Function>[],\n                              init?: ProtoProcessor<InitMethod>,\n                              config?: ProtoProcessor<ConfigMethod>,\n                              priority?: number,\n                              parser?: string,\n                             } = {}): Configuration {\n    return Configuration._create('', config);\n  }\n\n\n  /**\n   * @constructor\n   */\n  private constructor(readonly name: string,\n                      readonly handler: HandlerConfig = {},\n                      readonly fallback: FallbackConfig = {},\n                      readonly items: StackItemConfig = {},\n                      readonly tags: TagsConfig = {},\n                      readonly options: OptionList = {},\n                      readonly nodes: {[key: string]: any} = {},\n                      readonly preprocessors: ProcessorList = [],\n                      readonly postprocessors: ProcessorList = [],\n                      readonly initMethod: Processor<InitMethod> = null,\n                      readonly configMethod: Processor<ConfigMethod> = null,\n                      public priority: number,\n                      readonly parser: string\n                     ) {\n    this.handler = Object.assign(\n      {character: [], delimiter: [], macro: [], environment: []}, handler);\n  }\n\n  /**\n   * The init method.\n   * @type {Function}\n   */\n  public get init(): InitMethod {\n    return this.initMethod ? this.initMethod[0] : null;\n  }\n\n  /**\n   * The config method to call once jax is ready.\n   * @type {FunctionList}\n   */\n  public get config(): ConfigMethod {\n    return this.configMethod ? this.configMethod[0] : null;\n  }\n\n}\n\n\nexport namespace ConfigurationHandler {\n\n  let maps: Map<string, Configuration> = new Map();\n\n  /**\n   * Adds a new configuration to the handler overwriting old ones.\n   *\n   * @param {string} name The name of the configuration.\n   * @param {Configuration} map The configuration mapping.\n   */\n  export let set = function(name: string, map: Configuration): void {\n    maps.set(name, map);\n  };\n\n\n  /**\n   * Looks up a configuration.\n   *\n   * @param {string} name The name of the configuration.\n   * @return {Configuration} The configuration with the given name or null.\n   */\n  export let get = function(name: string): Configuration {\n    return maps.get(name);\n  };\n\n  /**\n   * @return {string[]} All configurations in the handler.\n   */\n  export let keys = function(): IterableIterator<string> {\n    return maps.keys();\n  };\n\n}\n\n\n/**\n * Parser configuration combines the configurations of the currently selected\n * packages.\n * @constructor\n */\nexport class ParserConfiguration {\n\n  /**\n   * Priority list of init methods.\n   * @type {FunctionList}\n   */\n  protected initMethod: FunctionList = new FunctionList();\n\n  /**\n   * Priority list of init methods to call once jax is ready.\n   * @type {FunctionList}\n   */\n  protected configMethod: FunctionList = new FunctionList();\n\n  /**\n   * An ordered list of cofigurations.\n   * @type {PrioritizedList<Configuration>}\n   */\n  protected configurations: PrioritizedList<Configuration> = new PrioritizedList();\n\n  /**\n   * The list of parsers this configuration targets\n   */\n  protected parsers: string[] = [];\n\n  /**\n   * The subhandlers for this configuration.\n   * @type {SubHandlers}\n   */\n  public handlers: SubHandlers = new SubHandlers();\n\n  /**\n   * The collated stack items.\n   * @type {StackItemConfig}\n   */\n  public items: StackItemConfig = {};\n\n  /**\n   * The collated tag configurations.\n   * @type {TagsConfig}\n   */\n  public tags: TagsConfig = {};\n\n  /**\n   * The collated options.\n   * @type {OptionList}\n   */\n  public options: OptionList = {};\n\n  /**\n   * The collated node creators.\n   * @type {{[key: string]: any}}\n   */\n  public nodes: {[key: string]: any}  = {};\n\n  /**\n   * @constructor\n   * @param {(string|[string,number])[]} packages A list of packages with\n   *     optional priorities.\n   * @parm {string[]} parsers   The names of the parsers this package targets\n   */\n  constructor(packages: (string | [string, number])[], parsers: string[] = ['tex']) {\n    this.parsers = parsers;\n    for (const pkg of packages.slice().reverse()) {\n      this.addPackage(pkg);\n    }\n    for (let {item: config, priority: priority} of this.configurations) {\n      this.append(config, priority);\n    }\n  }\n\n  /**\n   * Init method for the configuration;\n   */\n  public init() {\n    this.initMethod.execute(this);\n  }\n\n  /**\n   * Init method for when the jax is ready\n   * @param {TeX} jax The TeX jax for this configuration\n   */\n  public config(jax: TeX<any, any, any>) {\n    this.configMethod.execute(this, jax);\n    for (const config of this.configurations) {\n      this.addFilters(jax, config.item);\n    }\n  }\n\n  /**\n   * Retrieves and adds configuration for a package with priority.\n   * @param {(string | [string, number]} pkg Package with priority.\n   */\n  public addPackage(pkg: (string | [string, number])) {\n    const name = typeof pkg === 'string' ? pkg : pkg[0];\n    const conf = this.getPackage(name);\n    conf && this.configurations.add(conf, typeof pkg === 'string' ? conf.priority : pkg[1]);\n  }\n\n  /**\n   * Adds a configuration after the input jax is created.  (Used by \\require.)\n   * Sets items, nodes and runs configuration method explicitly.\n   *\n   * @param {string} name            The name of the package to add\n   * @param {TeX} jax                The TeX jax where it is being registered\n   * @param {OptionList=} options    The options for the configuration.\n   */\n  public add(name: string, jax: TeX<any, any, any>, options: OptionList = {}) {\n    const config = this.getPackage(name);\n    this.append(config);\n    this.configurations.add(config, config.priority);\n    this.init();\n    const parser = jax.parseOptions;\n    parser.nodeFactory.setCreators(config.nodes);\n    for (const kind of Object.keys(config.items)) {\n      parser.itemFactory.setNodeClass(kind, config.items[kind]);\n    }\n    TagsFactory.addTags(config.tags);\n    defaultOptions(parser.options, config.options);\n    userOptions(parser.options, options);\n    this.addFilters(jax, config);\n    if (config.config) {\n      config.config(this, jax);\n    }\n  }\n\n /**\n  * Find a package and check that it is for the targeted parser\n  *\n  * @param {string} name       The name of the package to check\n  * @return {Configuration}    The configuration for the package\n  */\n  protected getPackage(name: string): Configuration {\n    const config = ConfigurationHandler.get(name);\n    if (config && this.parsers.indexOf(config.parser) < 0) {\n      throw Error(`Package ${name} doesn't target the proper parser`);\n    }\n    return config;\n  }\n\n  /**\n   * Appends a configuration to the overall configuration object.\n   * @param {Configuration} config A configuration.\n   * @param {number} priority The configurations optional priority.\n   */\n  public append(config: Configuration, priority?: number) {\n    priority = priority || config.priority;\n    if (config.initMethod) {\n      this.initMethod.add(config.initMethod[0], config.initMethod[1]);\n    }\n    if (config.configMethod) {\n        this.configMethod.add(config.configMethod[0], config.configMethod[1]);\n      }\n    this.handlers.add(config.handler, config.fallback, priority);\n    Object.assign(this.items, config.items);\n    Object.assign(this.tags, config.tags);\n    defaultOptions(this.options, config.options);\n    Object.assign(this.nodes, config.nodes);\n  }\n\n  /**\n   * Adds pre- and postprocessor as filters to the jax.\n   * @param {TeX<any} jax The TeX Jax.\n   * @param {Configuration} config The configuration whose processors are added.\n   */\n  private addFilters(jax: TeX<any, any, any>, config: Configuration) {\n    for (const [pre, priority] of config.preprocessors) {\n      jax.preFilters.add(pre, priority);\n    }\n    for (const [post, priority] of config.postprocessors) {\n      jax.postFilters.add(post, priority);\n    }\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Singleton class for handling symbol maps.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {AbstractSymbolMap, SymbolMap} from './SymbolMap.js';\nimport {ParseInput, ParseResult, ParseMethod} from './Types.js';\n// import {ParserConfiguration} from './Configuration.js';\nimport {PrioritizedList} from '../../util/PrioritizedList.js';\nimport {FunctionList} from '../../util/FunctionList.js';\n\n\nexport type HandlerType = 'delimiter' | 'macro' | 'character' | 'environment';\n\nexport type HandlerConfig = {[P in HandlerType]?: string[]};\nexport type FallbackConfig = {[P in HandlerType]?: ParseMethod};\n\n\nexport namespace MapHandler {\n\n  let maps: Map<string, SymbolMap> = new Map();\n\n  /**\n   * Adds a new symbol map to the map handler. Might overwrite an existing\n   * symbol map of the same name.\n   *\n   * @param {SymbolMap} map Registers a new symbol map.\n   */\n  export let register = function(map: SymbolMap): void {\n    maps.set(map.name, map);\n  };\n\n\n  /**\n   * Looks up a symbol map if it exists.\n   *\n   * @param {string} name The name of the symbol map.\n   * @return {SymbolMap} The symbol map with the given name or null.\n   */\n  export let getMap = function(name: string): SymbolMap {\n    return maps.get(name);\n  };\n\n}\n\n\n/**\n * Class of symbol mappings that are active in a configuration.\n */\nexport class SubHandler {\n\n  private _configuration: PrioritizedList<SymbolMap> = new PrioritizedList<SymbolMap>();\n  private _fallback: FunctionList = new FunctionList();\n\n  /**\n   * Adds a list of symbol maps to the handler.\n   * @param {string[]} maps The names of the symbol maps to add.\n   * @param {ParseMethod} fallback A fallback method.\n   * @param {number} priority Optionally a priority.\n   */\n  public add(maps: string[], fallback: ParseMethod,\n             priority: number = PrioritizedList.DEFAULTPRIORITY) {\n    for (const name of maps.slice().reverse()) {\n      let map = MapHandler.getMap(name);\n      if (!map) {\n        this.warn('Configuration ' + name + ' not found! Omitted.');\n        return;\n      }\n      this._configuration.add(map, priority);\n    }\n    if (fallback) {\n      this._fallback.add(fallback, priority);\n    }\n  }\n\n  /**\n   * Parses the given input with the first applicable symbol map.\n   * @param {ParseInput} input The input for the parser.\n   * @return {ParseResult} The output of the parsing function.\n   */\n  public parse(input: ParseInput): ParseResult {\n    for (let {item: map} of this._configuration) {\n      const result = map.parse(input);\n      if (result) {\n        return result;\n      }\n    }\n    let [env, symbol] = input;\n    Array.from(this._fallback)[0].item(env, symbol);\n  }\n\n\n  /**\n   * Maps a symbol to its \"parse value\" if it exists.\n   *\n   * @param {string} symbol The symbol to parse.\n   * @return {T} A boolean, Character, or Macro.\n   */\n  public lookup<T>(symbol: string): T {\n    let map = this.applicable(symbol) as AbstractSymbolMap<T>;\n    return map ? map.lookup(symbol) : null;\n  }\n\n\n  /**\n   * Checks if a symbol is contained in one of the symbol mappings of this\n   * configuration.\n   *\n   * @param {string} symbol The symbol to parse.\n   * @return {boolean} True if the symbol is contained in the mapping.\n   */\n  public contains(symbol: string): boolean {\n    return this.applicable(symbol) ? true : false;\n  }\n\n\n  /**\n   * @override\n   */\n  public toString(): string {\n    let names = [];\n    for (let {item: map} of this._configuration) {\n      names.push(map.name);\n    }\n    return names.join(', ');\n  }\n\n\n  /**\n   * Retrieves the first applicable symbol map in the configuration.\n   * @param {string} symbol The symbol to parse.\n   * @return {SymbolMap} A map that can parse the symbol.\n   */\n  public applicable(symbol: string): SymbolMap {\n    for (let {item: map} of this._configuration) {\n      if (map.contains(symbol)) {\n        return map;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Retrieves the map of the given name.\n   * @param {string} name Name of the symbol map.\n   * @return {SymbolMap} The map if it exists.\n   */\n  public retrieve(name: string): SymbolMap {\n    for (let {item: map} of this._configuration) {\n      if (map.name === name) {\n        return map;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Prints a warning message.\n   * @param {string} message The warning.\n   */\n  private warn(message: string) {\n    console.log('TexParser Warning: ' + message);\n  }\n\n}\n\n\nexport class SubHandlers {\n\n  private map = new Map<HandlerType, SubHandler>();\n\n  /**\n   * Adds a symbol map to the configuration if it exists.\n   * @param {string} name of the symbol map.\n   */\n  public add(handlers: HandlerConfig, fallbacks: FallbackConfig,\n             priority: number = PrioritizedList.DEFAULTPRIORITY): void {\n    for (const key of Object.keys(handlers)) {\n      let name = key as HandlerType;\n      let subHandler = this.get(name);\n      if (!subHandler) {\n        subHandler = new SubHandler();\n        this.set(name, subHandler);\n      }\n      subHandler.add(handlers[name], fallbacks[name], priority);\n    }\n  }\n\n\n  /**\n   * Setter for subhandlers.\n   * @param {HandlerType} name The name of the subhandler.\n   * @param {SubHandler} subHandler The subhandler.\n   */\n  public set(name: HandlerType, subHandler: SubHandler) {\n    this.map.set(name, subHandler);\n  }\n\n\n  /**\n   * Getter for subhandler.\n   * @param {HandlerType} name Name of the subhandler.\n   * @return {SubHandler} The subhandler by that name if it exists.\n   */\n  public get(name: HandlerType): SubHandler {\n    return this.map.get(name);\n  }\n\n\n  /**\n   * Retrieves a symbol map of the given name.\n   * @param {string} name Name of the symbol map.\n   * @return {SymbolMap} The map if it exists. O/w null.\n   */\n  public retrieve(name: string): SymbolMap {\n    for (const handler of this.map.values()) {\n      let map = handler.retrieve(name);\n      if (map) {\n        return map;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * All names of registered subhandlers.\n   * @return {IterableIterator<string>} Iterable list of keys.\n   */\n  public keys(): IterableIterator<string> {\n    return this.map.keys();\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2009-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Node utility methods.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {TextNode, MMLNODE, MmlNode, AbstractMmlNode, AbstractMmlEmptyNode} from '../../core/MmlTree/MmlNode.js';\nimport {MmlMo} from '../../core/MmlTree/MmlNodes/mo.js';\nimport {Property, PropertyList} from '../../core/Tree/Node.js';\nimport {Args} from './Types.js';\nimport {OperatorDef} from '../../core/MmlTree/OperatorDictionary.js';\n\n\nnamespace NodeUtil {\n\n  const attrs: Map<String, boolean> = new Map([\n    ['autoOP', true],\n    ['fnOP', true],\n    ['movesupsub', true],\n    ['subsupOK', true],\n    ['texprimestyle', true],\n    ['useHeight', true],\n    ['variantForm', true],\n    ['withDelims', true],\n    ['mathaccent', true],\n    ['open', true],\n    ['close', true]\n  ]);\n\n\n  /**\n   * Creates a single character from a unicode hex string.\n   * @param {string} code The code.\n   * @return {string} The newly created entity.\n   */\n  export function createEntity(code: string): string  {\n    return String.fromCodePoint(parseInt(code, 16));\n  }\n\n\n  /**\n   * Get the children of the a node.\n   * @param {MmlNode} node The node.\n   * @return {MMLNODE[]} Its children.\n   */\n  export function getChildren(node: MmlNode): MMLNODE[] {\n    return (node.childNodes as MMLNODE[]);\n  }\n\n\n  /**\n   * Get text content of a node.\n   * @param {TextNode} node The node.\n   * @return {string} Its text content.\n   */\n  export function getText(node: TextNode): string {\n    return node.getText();\n  }\n\n\n  /**\n   * Append children to a node.\n   * @param {MmlNode} node The node.\n   * @param {MMLNODE[]} children A list of new children.\n   */\n  export function appendChildren(node: MmlNode, children: MMLNODE[])  {\n    for (let child of children) {\n      node.appendChild(child);\n    }\n  }\n\n\n  /**\n   * Sets an attribute of a node.\n   * @param {MmlNode} node The node.\n   * @param {string} attribute An attribute.\n   * @param {Args} value The attribute value.\n   */\n  export function setAttribute(node: MmlNode, attribute: string, value: Args) {\n    node.attributes.set(attribute, value);\n  }\n\n\n  /**\n   * Sets a property of a node.\n   * @param {MmlNode} node The node.\n   * @param {string} property The property.\n   * @param {Args} value The property value.\n   */\n  export function setProperty(node: MmlNode, property: string, value: Args) {\n    node.setProperty(property, value);\n  }\n\n\n  /**\n   * Sets properties and attributes of a node.\n   * @param {MmlNode} node The node.\n   * @param {PropertyList} properties A list of property/attribute value pairs.\n   */\n  export function setProperties(node: MmlNode, properties: PropertyList) {\n    for (const name of Object.keys(properties)) {\n      let value = properties[name];\n      if (name === 'texClass') {\n        node.texClass = (value as number);\n        node.setProperty(name, value);\n      } else if (name === 'movablelimits') {\n        node.setProperty('movablelimits', value);\n        if (node.isKind('mo') || node.isKind('mstyle')) {\n          node.attributes.set('movablelimits', value);\n        }\n      } else if (name === 'inferred') {\n        // ignore\n      } else if (attrs.has(name)) {\n        node.setProperty(name, value);\n      } else {\n        node.attributes.set(name, value);\n      }\n    }\n  }\n\n\n  /**\n   * Returns the property of a node.\n   * @param {MmlNode} node The node.\n   * @param {string} property A property name.\n   * @return {Property} Value of the property.\n   */\n  export function getProperty(node: MmlNode, property: string): Property  {\n    return node.getProperty(property);\n  }\n\n\n  /**\n   * Returns the attribute of a node.\n   * @param {MmlNode} node The node.\n   * @param {string} attr A attribute name.\n   * @return {Property} Value of the attribute.\n   */\n  export function getAttribute(node: MmlNode, attr: string): Property  {\n    return node.attributes.get(attr);\n  }\n\n\n  /**\n   * Removes a set of properties from a node.\n   * @param {MmlNode} node The node.\n   * @param {string[]} ...properties  A list of properties.\n   */\n  export function removeProperties(node: MmlNode, ...properties: string[]) {\n    node.removeProperty(...properties);\n  }\n\n\n  /**\n   * Returns a child node at a given position.\n   * @param {MmlNode} node The node.\n   * @param {number} position The position of the child.\n   * @return {MMLNODE} The child node at position.\n   */\n  export function getChildAt(node: MmlNode, position: number): MMLNODE {\n    return (node.childNodes[position] as MMLNODE);\n  }\n\n\n  /**\n   * Set node child at position.\n   * @param {MmlNode} node The node.\n   * @param {number} position The position of the new child.\n   * @param {MmlNode} child The new child.\n   */\n  export function setChild(node: MmlNode, position: number, child: MmlNode) {\n    let children = node.childNodes;\n    children[position] = child;\n    if (child) {\n      child.parent = node;\n    }\n  }\n\n\n  /**\n   * Copies children between nodes.\n   * @param {MmlNode} oldNode The source node.\n   * @param {MmlNode} newNode The target node.\n   */\n  export function copyChildren(oldNode: MmlNode, newNode: MmlNode) {\n    let children = oldNode.childNodes as (TextNode | MmlNode)[];\n    for (let i = 0; i < children.length; i++) {\n      setChild(newNode, i, children[i]);\n    }\n  }\n\n\n  /**\n   * Copies attributes between nodes.\n   * @param {MmlNode} oldNode The source node.\n   * @param {MmlNode} newNode The target node.\n   */\n  export function copyAttributes(oldNode: MmlNode, newNode: MmlNode) {\n    newNode.attributes = oldNode.attributes;\n    setProperties(newNode, oldNode.getAllProperties());\n  }\n\n\n  /**\n   * Checks if node is of a particular type.\n   * @param {MmlNode} node The node.\n   * @param {string} kind The type to check.\n   * @return {boolean} True if node is of the given type.\n   */\n  export function isType(node: MmlNode, kind: string): boolean  {\n    return node.isKind(kind);\n  }\n\n\n  /**\n   * Checks if the node is embellished.\n   * @param {MmlNode} node The node.\n   * @return {boolean} True if node is embellished.\n   */\n  export function isEmbellished(node: MmlNode): boolean {\n    return node.isEmbellished;\n  }\n\n\n  /**\n   * Gets the texclass of a node.\n   * @param {MmlNode} node The node.\n   * @return {number} Its texclass.\n   */\n  export function getTexClass(node: MmlNode): number  {\n    return node.texClass;\n  }\n\n\n  /**\n   * Gets the mo element at the core of the node.\n   * @param {MmlNode} node The node.\n   * @return {MmlNode} The MO node at the core.\n   */\n  export function getCoreMO(node: MmlNode): MmlNode  {\n    return node.coreMO();\n  }\n\n\n  /**\n   * Checks if an object is a node.\n   * @param {any} item The object.\n   * @return {boolean} True if it is a node.\n   */\n  export function isNode(item: any): boolean  {\n    return item instanceof AbstractMmlNode || item instanceof AbstractMmlEmptyNode;\n  }\n\n\n  /**\n   * Checks if the node is an inferred mrow.\n   * @param {MmlNode} node The node.\n   * @return {boolean} True if the node is an inferred mrow.\n   */\n  export function isInferred(node: MmlNode): boolean {\n    return node.isInferred;\n  }\n\n\n  /**\n   * Gets the operator definition of a node.\n   * @param {MmlNode} node The node.\n   * @return {OperatorDef} If node is an MO returns the operator definition. O/w\n   *    null.\n   */\n  export function getForm(node: MmlNode): OperatorDef {\n    if (!isType(node, 'mo')) {\n      return null;\n    }\n    let mo = node as MmlMo;\n    let forms = mo.getForms();\n    for (let form of forms) {\n      let symbol = MmlMo.OPTABLE[form][mo.getText()];\n      if (symbol) {\n        return symbol;\n      }\n    }\n    return null;\n  }\n\n}\n\nexport default NodeUtil;\n","/*************************************************************\n *\n *  Copyright (c) 2009-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview A namespace for utility functions for the TeX Parser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {TEXCLASS, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {EnvList} from './StackItem.js';\nimport {ArrayItem} from './base/BaseItems.js';\nimport ParseOptions from './ParseOptions.js';\nimport NodeUtil from './NodeUtil.js';\nimport TexParser from './TexParser.js';\nimport TexError from './TexError.js';\nimport {entities} from '../../util/Entities.js';\nimport {MmlMunderover} from '../../core/MmlTree/MmlNodes/munderover.js';\n\n\nnamespace ParseUtil {\n\n  // TODO (VS): Combine some of this with lengths in util.\n  const emPerInch = 7.2;\n  const pxPerInch = 72;\n  // Note, the following are TeX CM font values.\n  const UNIT_CASES: {[key: string]: ((m: number) => number)}  = {\n    'em': m => m,\n    'ex': m => m * .43,\n    'pt': m => m / 10,                    // 10 pt to an em\n    'pc': m => m * 1.2,                   // 12 pt to a pc\n    'px': m => m * emPerInch / pxPerInch,\n    'in': m => m * emPerInch,\n    'cm': m => m * emPerInch / 2.54, // 2.54 cm to an inch\n    'mm': m => m * emPerInch / 25.4, // 10 mm to a cm\n    'mu': m => m / 18,\n  };\n  const num = '([-+]?([.,]\\\\d+|\\\\d+([.,]\\\\d*)?))';\n  const unit = '(pt|em|ex|mu|px|mm|cm|in|pc)';\n  const dimenEnd = RegExp('^\\\\s*' + num + '\\\\s*' + unit + '\\\\s*$');\n  const dimenRest = RegExp('^\\\\s*' + num + '\\\\s*' + unit + ' ?');\n\n\n  /**\n   * Matches for a dimension argument.\n   * @param {string} dim The argument.\n   * @param {boolean} rest Allow for trailing garbage in the dimension string.\n   * @return {[string, string, number]} The match result as (Anglosaxon) value,\n   *     unit name, length of matched string. The latter is interesting in the\n   *     case of trailing garbage.\n   */\n  export function matchDimen(\n    dim: string, rest: boolean = false): [string, string, number] {\n      let match = dim.match(rest ? dimenRest : dimenEnd);\n      return match ?\n        muReplace([match[1].replace(/,/, '.'), match[4], match[0].length]) :\n        [null, null, 0];\n  }\n\n\n  /**\n   * Transforms mu dimension to em if necessary.\n   * @param {[string, string, number]} [value, unit, length] The dimension triple.\n   * @return {[string, string, number]} [value, unit, length] The transformed triple.\n   */\n  function muReplace([value, unit, length]: [string, string, number]): [string, string, number] {\n    if (unit !== 'mu') {\n      return [value, unit, length];\n    }\n    let em = Em(UNIT_CASES[unit](parseFloat(value || '1')));\n    return [em.slice(0, -2), 'em', length];\n  }\n\n\n  /**\n   * Convert a dimension string into standard em dimension.\n   * @param {string} dim The attribute string.\n   * @return {number} The numerical value.\n   */\n  export function dimen2em(dim: string): number {\n    let [value, unit] = matchDimen(dim);\n    let m = parseFloat(value || '1');\n    let func = UNIT_CASES[unit];\n    return func ? func(m) : 0;\n  }\n\n\n  /**\n   * Turns a number into an em value.\n   * @param {number} m The number.\n   * @return {string} The em dimension string.\n   */\n  export function Em(m: number): string {\n    if (Math.abs(m) < .0006) {\n      return '0em';\n    }\n    return m.toFixed(3).replace(/\\.?0+$/, '') + 'em';\n  }\n\n\n  /**\n   * Takes an array of numbers and returns a space-separated string of em values.\n   * @param {number[]} W  The widths to be turned into em values\n   * @return {string}     The numbers with em units, separated by spaces.\n   */\n  export function cols(...W: number[]): string {\n    return W.map(n => Em(n)).join(' ');\n  }\n\n\n  /**\n   * Create an mrow that has stretchy delimiters at either end, as needed\n   * @param {ParseOptions} configuration Current parse options.\n   * @param {string} open The opening fence.\n   * @param {MmlNode} mml The enclosed node.\n   * @param {string} close The closing fence.\n   * @param {string=} big Bigg command.\n   */\n  export function fenced(configuration: ParseOptions, open: string, mml: MmlNode,\n                         close: string, big: string = '', color: string = '') {\n    // @test Fenced, Fenced3\n    let nf = configuration.nodeFactory;\n    let mrow = nf.create('node', 'mrow', [],\n                         {open: open, close: close, texClass: TEXCLASS.INNER});\n    let mo;\n    if (big) {\n      mo = new TexParser('\\\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();\n    } else {\n      let openNode = nf.create('text', open);\n      mo = nf.create('node', 'mo', [],\n                     {fence: true, stretchy: true, symmetric: true, texClass: TEXCLASS.OPEN},\n                     openNode);\n    }\n    NodeUtil.appendChildren(mrow, [mo, mml]);\n    if (big) {\n      mo = new TexParser('\\\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();\n    } else {\n      let closeNode = nf.create('text', close);\n      mo = nf.create('node', 'mo', [],\n                     {fence: true, stretchy: true, symmetric: true, texClass: TEXCLASS.CLOSE},\n                     closeNode);\n    }\n    color && mo.attributes.set('mathcolor', color);\n    NodeUtil.appendChildren(mrow, [mo]);\n    return mrow;\n  }\n\n\n  /**\n   *  Create an mrow that has \\\\mathchoice using \\\\bigg and \\\\big for the delimiters.\n   * @param {ParseOptions} configuration The current parse options.\n   * @param {string} open The opening fence.\n   * @param {MmlNode} mml The enclosed node.\n   * @param {string} close The closing fence.\n   * @return {MmlNode} The mrow node.\n   */\n  export function fixedFence(configuration: ParseOptions, open: string,\n                             mml: MmlNode, close: string): MmlNode {\n    // @test Choose, Over With Delims, Above with Delims\n    let mrow = configuration.nodeFactory.create('node',\n      'mrow', [], {open: open, close: close, texClass: TEXCLASS.ORD});\n    if (open) {\n      NodeUtil.appendChildren(mrow, [mathPalette(configuration, open, 'l')]);\n    }\n    if (NodeUtil.isType(mml, 'mrow')) {\n      NodeUtil.appendChildren(mrow, NodeUtil.getChildren(mml));\n    } else {\n      NodeUtil.appendChildren(mrow, [mml]);\n    }\n    if (close) {\n      NodeUtil.appendChildren(mrow, [mathPalette(configuration, close, 'r')]);\n    }\n    return mrow;\n  }\n\n\n  /**\n   * Generates a mathchoice element for fences. These will be resolved later,\n   * once the position, and therefore size, of the of the fenced expression is\n   * known.\n   * @param {ParseOptions} configuration The current parse otpions.\n   * @param {string} fence The fence.\n   * @param {string} side The side of the fence (l or r).\n   * @return {MmlNode} The mathchoice node.\n   */\n  export function mathPalette(configuration: ParseOptions, fence: string,\n                              side: string): MmlNode  {\n    if (fence === '{' || fence === '}') {\n      fence = '\\\\' + fence;\n    }\n    let D = '{\\\\bigg' + side + ' ' + fence + '}';\n    let T = '{\\\\big' + side + ' ' + fence + '}';\n    return new TexParser('\\\\mathchoice' + D + T + T + T, {}, configuration).mml();\n  }\n\n\n  /**\n   * If the initial child, skipping any initial space or\n   * empty braces (TeXAtom with child being an empty inferred row),\n   * is an <mo>, precede it by an empty <mi> to force the <mo> to\n   * be infix.\n   * @param {ParseOptions} configuration The current parse options.\n   * @param {MmlNode[]} nodes The row of nodes to scan for an initial <mo>\n   */\n  export function fixInitialMO(configuration: ParseOptions, nodes: MmlNode[]) {\n    for (let i = 0, m = nodes.length; i < m; i++) {\n      let child = nodes[i];\n      if (child && (!NodeUtil.isType(child, 'mspace') &&\n                    (!NodeUtil.isType(child, 'TeXAtom') ||\n                     (NodeUtil.getChildren(child)[0] &&\n                      NodeUtil.getChildren(NodeUtil.getChildren(child)[0]).length)))) {\n        if (NodeUtil.isEmbellished(child) ||\n            (NodeUtil.isType(child, 'TeXAtom') && NodeUtil.getTexClass(child) === TEXCLASS.REL)) {\n          let mi = configuration.nodeFactory.create('node', 'mi');\n          nodes.unshift(mi);\n        }\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * Break up a string into text and math blocks.\n   * @param {TexParser} parser The calling parser.\n   * @param {string} text The text in the math expression to parse.\n   * @param {number|string=} level The scriptlevel.\n   * @param {string} font The mathvariant to use\n   * @return {MmlNode[]} The nodes corresponding to the internal math expression.\n   */\n  export function internalMath(parser: TexParser, text: string,\n                               level?: number | string, font?: string): MmlNode[] {\n    if (parser.configuration.options.internalMath) {\n      return parser.configuration.options.internalMath(parser, text, level, font);\n    }\n    let mathvariant = font || parser.stack.env.font;\n    let def = (mathvariant ? {mathvariant} : {});\n    let mml: MmlNode[] = [], i = 0, k = 0, c, node, match = '', braces = 0;\n    if (text.match(/\\\\?[${}\\\\]|\\\\\\(|\\\\(eq)?ref\\s*\\{/)) {\n      while (i < text.length) {\n        c = text.charAt(i++);\n        if (c === '$') {\n          if (match === '$' && braces === 0) {\n            // @test Interspersed Text\n            node = parser.create(\n              'node', 'TeXAtom',\n              [(new TexParser(text.slice(k, i - 1), {}, parser.configuration)).mml()]);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match === '') {\n            // @test Interspersed Text\n            if (k < i - 1) {\n              // @test Interspersed Text\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '$';\n            k = i;\n          }\n        } else if (c === '{' && match !== '') {\n          // @test Mbox Mbox, Mbox Math\n          braces++;\n        } else if (c === '}') {\n          // @test Mbox Mbox, Mbox Math\n          if (match === '}' && braces === 0) {\n            // @test Mbox Eqref, Mbox Math\n            let atom = (new TexParser(text.slice(k, i), {}, parser.configuration)).mml();\n            node = parser.create('node', 'TeXAtom', [atom], def);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match !== '') {\n            // @test Mbox Math, Mbox Mbox\n            if (braces) {\n              // @test Mbox Math, Mbox Mbox\n              braces--;\n            }\n          }\n        } else if (c === '\\\\') {\n          // @test Mbox Eqref, Mbox CR\n          if (match === '' && text.substr(i).match(/^(eq)?ref\\s*\\{/)) {\n            // @test Mbox Eqref\n            let len = ((RegExp as any)['$&'] as string).length;\n            if (k < i - 1) {\n              // @test Mbox Eqref\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '}';\n            k = i - 1;\n            i += len;\n          } else {\n            // @test Mbox CR, Mbox Mbox\n            c = text.charAt(i++);\n            if (c === '(' && match === '') {\n              // @test Mbox Internal Display\n              if (k < i - 2) {\n                // @test Mbox Internal Display\n                mml.push(internalText(parser, text.slice(k, i - 2), def));\n              }\n              match = ')'; k = i;\n            } else if (c === ')' && match === ')' && braces === 0) {\n              // @test Mbox Internal Display\n              node = parser.create(\n                'node', 'TeXAtom',\n                [(new TexParser(text.slice(k, i - 2), {}, parser.configuration)).mml()]);\n              mml.push(node);\n              match = '';\n              k = i;\n            } else if (c.match(/[${}\\\\]/) && match === '')  {\n              // @test Mbox CR\n              i--;\n              text = text.substr(0, i - 1) + text.substr(i); // remove \\ from \\$, \\{, \\}, or \\\\\n            }\n          }\n        }\n      }\n      if (match !== '') {\n        // @test Internal Math Error\n        throw new TexError('MathNotTerminated', 'Math not terminated in text box');\n      }\n    }\n    if (k < text.length) {\n      // @test Interspersed Text, Mbox Mbox\n      mml.push(internalText(parser, text.slice(k), def));\n    }\n    if (level != null) {\n      // @test Label, Fbox, Hbox\n      mml = [parser.create('node', 'mstyle', mml, {displaystyle: false, scriptlevel: level})];\n    } else if (mml.length > 1) {\n      // @test Interspersed Text\n      mml = [parser.create('node', 'mrow', mml)];\n    }\n    return mml;\n  }\n\n\n  /**\n   * Parses text internal to boxes or labels.\n   * @param {TexParser} parser The current tex parser.\n   * @param {string} text The text to parse.\n   * @param {EnvList} def The attributes of the text node.\n   * @return {MmlNode} The text node.\n   */\n  export function internalText(parser: TexParser, text: string, def: EnvList): MmlNode {\n    // @test Label, Fbox, Hbox\n    text = text.replace(/^\\s+/, entities.nbsp).replace(/\\s+$/, entities.nbsp);\n    let textNode = parser.create('text', text);\n    return parser.create('node', 'mtext', [], def, textNode);\n  }\n\n  /**\n   * Create an munderover node with the given script position.\n   * @param {TexParser} parser   The current TeX parser.\n   * @param {MmlNode} base       The base node.\n   * @param {MmlNode} script     The under- or over-script.\n   * @param {string} pos         Either 'over' or 'under'.\n   * @param {boolean} stack      True if super- or sub-scripts should stack.\n   * @return {MmlNode}           The generated node (MmlMunderover or TeXAtom)\n   */\n  export function underOver(parser: TexParser, base: MmlNode, script: MmlNode, pos: string, stack: boolean): MmlNode {\n    // @test Overline\n    ParseUtil.checkMovableLimits(base);\n    if (NodeUtil.isType(base, 'munderover') && NodeUtil.isEmbellished(base)) {\n      // @test Overline Limits\n      NodeUtil.setProperties(NodeUtil.getCoreMO(base), {lspace: 0, rspace: 0});\n      const mo = parser.create('node', 'mo', [], {rspace: 0});\n      base = parser.create('node', 'mrow', [mo, base]);\n      // TODO? add an empty <mi> so it's not embellished any more\n    }\n    const mml = parser.create('node', 'munderover', [base]) as MmlMunderover;\n    NodeUtil.setChild(mml, pos === 'over' ?  mml.over : mml.under, script);\n    let node: MmlNode = mml;\n    if (stack) {\n      // @test Overbrace 1 2 3, Underbrace, Overbrace Op 1 2\n      node = parser.create('node', 'TeXAtom', [mml], {texClass: TEXCLASS.OP, movesupsub: true});\n    }\n    NodeUtil.setProperty(node, 'subsupOK', true);\n    return node;\n  }\n\n  /**\n   * Set movablelimits to false if necessary.\n   * @param {MmlNode} base   The base node being tested.\n   */\n  export function checkMovableLimits(base: MmlNode) {\n    const symbol = (NodeUtil.isType(base, 'mo') ? NodeUtil.getForm(base) : null);\n    if (NodeUtil.getProperty(base, 'movablelimits') || (symbol && symbol[3] && symbol[3].movablelimits)) {\n      // @test Overline Sum\n      NodeUtil.setProperties(base, {movablelimits: false});\n    }\n  }\n\n  /**\n   * Trim spaces from a string.\n   * @param {string} text The string to clean.\n   * @return {string} The string with leading and trailing whitespace removed.\n   */\n  export function trimSpaces(text: string): string {\n    if (typeof(text) !== 'string') {\n      return text;\n    }\n    let TEXT = text.trim();\n    if (TEXT.match(/\\\\$/) && text.match(/ $/)) {\n      TEXT += ' ';\n    }\n    return TEXT;\n  }\n\n\n  /**\n   * Sets alignment in array definitions.\n   * @param {ArrayItem} array The array item.\n   * @param {string} align The alignment string.\n   * @return {ArrayItem} The altered array item.\n   */\n  export function setArrayAlign(array: ArrayItem, align: string): ArrayItem {\n    // @test Array1, Array2, Array Test\n    align = ParseUtil.trimSpaces(align || '');\n    if (align === 't') {\n      array.arraydef.align = 'baseline 1';\n    } else if (align === 'b') {\n      array.arraydef.align = 'baseline -1';\n    } else if (align === 'c') {\n      array.arraydef.align = 'axis';\n    } else if (align) {\n      array.arraydef.align = align;\n    } // FIXME: should be an error?\n    return array;\n  }\n\n\n  /**\n   * Replace macro parameters with their values.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {string[]} args A list of arguments for macro parameters.\n   * @param {string} str The macro parameter string.\n   * @return {string} The string with all parameters replaced by arguments.\n   */\n  export function substituteArgs(parser: TexParser, args: string[],\n                                 str: string): string {\n    let text = '';\n    let newstring = '';\n    let i = 0;\n    while (i < str.length) {\n      let c = str.charAt(i++);\n      if (c === '\\\\') {\n        text += c + str.charAt(i++);\n      }\n      else if (c === '#') {\n        c = str.charAt(i++);\n        if (c === '#') {\n          text += c;\n        } else {\n          if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {\n            throw new TexError('IllegalMacroParam',\n                                'Illegal macro parameter reference');\n          }\n          newstring = addArgs(parser, addArgs(parser, newstring, text),\n                              args[parseInt(c, 10) - 1]);\n          text = '';\n        }\n      } else {\n        text += c;\n      }\n    }\n    return addArgs(parser, newstring, text);\n  }\n\n\n  /**\n   * Adds a new expanded argument to an already macro parameter string.  Makes\n   * sure that macros are followed by a space if their names could accidentally\n   * be continued into the following text.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {string} s1 The already expanded string.\n   * @param {string} s2 The string to add.\n   * @return {string} The combined string.\n   */\n  export function addArgs(parser: TexParser, s1: string, s2: string): string {\n    if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\\\])(\\\\\\\\)*\\\\[a-z]+$/i)) {\n      s1 += ' ';\n    }\n    if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {\n      throw new TexError('MaxBufferSize',\n                          'MathJax internal buffer size exceeded; is there a' +\n                          ' recursive macro call?');\n    }\n    return s1 + s2;\n  }\n\n  /**\n   * Report an error if there are too many macro substitutions.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {boolean} isMacro  True if we are substituting a macro, false for environment.\n   */\n  export function checkMaxMacros(parser: TexParser, isMacro: boolean = true) {\n    if (++parser.macroCount <= parser.configuration.options['maxMacros']) {\n      return;\n    }\n    if (isMacro) {\n      throw new TexError('MaxMacroSub1',\n                         'MathJax maximum macro substitution count exceeded; ' +\n                         'is here a recursive macro call?');\n    } else {\n      throw new TexError('MaxMacroSub2',\n                         'MathJax maximum substitution count exceeded; ' +\n                         'is there a recursive latex environment?');\n    }\n  }\n\n\n  /**\n   *  Check for bad nesting of equation environments\n   */\n  export function checkEqnEnv(parser: TexParser) {\n    if (parser.stack.global.eqnenv) {\n      // @test ErroneousNestingEq\n      throw new TexError('ErroneousNestingEq', 'Erroneous nesting of equation structures');\n    }\n    parser.stack.global.eqnenv = true;\n  }\n\n  /**\n   * Copy an MmlNode and add it (and its children) to the proper lists.\n   *\n   * @param {MmlNode} node       The MmlNode to copy\n   * @param {TexParser} parser   The active tex parser\n   * @return {MmlNode}           The duplicate tree\n   */\n  export function copyNode(node: MmlNode, parser: TexParser): MmlNode  {\n    const tree = node.copy() as MmlNode;\n    const options = parser.configuration;\n    tree.walkTree((n: MmlNode) => {\n      options.addNode(n.kind, n);\n      const lists = (n.getProperty('in-lists') as string || '').split(/,/);\n      for (const list of lists) {\n        list && options.addNode(list, n);\n      }\n    });\n    return tree;\n  }\n\n  /**\n   * This is a placeholder for future security filtering of attributes.\n   * @param {TexParser} parser The current parser.\n   * @param {string} name The attribute name.\n   * @param {string} value The attribute value to filter.\n   * @return {string} The filtered value.\n   */\n  export function MmlFilterAttribute(_parser: TexParser, _name: string, value: string): string {\n    // TODO: Implement in security package.\n    return value;\n  }\n\n\n  /**\n   * Initialises an stack environment with current font definition in the parser.\n   * @param {TexParser} parser The current tex parser.\n   * @return {EnvList} The initialised environment list.\n   */\n  export function getFontDef(parser: TexParser): EnvList {\n    const font = parser.stack.env['font'];\n    return (font ? {mathvariant: font} : {});\n  }\n\n\n  /**\n   * Splits a package option list of the form [x=y,z=1] into an attribute list\n   * of the form {x: y, z: 1}.\n   * @param {string} attrib The attributes of the package.\n   * @param {{[key: string]: number}?} allowed A list of allowed options. If\n   *     given only allowed arguments are returned.\n   * @param {boolean?} error If true, raises an exception if not allowed options\n   *     are found.\n   * @return {EnvList} The attribute list.\n   */\n  export function keyvalOptions(attrib: string,\n                                allowed: {[key: string]: number} = null,\n                                error: boolean = false): EnvList {\n    let def: EnvList = readKeyval(attrib);\n    if (allowed) {\n      for (let key of Object.keys(def)) {\n        if (!allowed.hasOwnProperty(key)) {\n          if (error) {\n            throw new TexError('InvalidOption', 'Invalid option: %1', key);\n          }\n          delete def[key];\n        }\n      }\n    }\n    return def;\n  }\n\n\n  /**\n   * Implementation of the keyval function from https://www.ctan.org/pkg/keyval\n   * @param {string} text The optional parameter string for a package or\n   *     command.\n   * @return {EnvList} Set of options as key/value pairs.\n   */\n  function readKeyval(text: string): EnvList {\n    let options: EnvList = {};\n    let rest = text;\n    let end, key, val;\n    while (rest) {\n      [key, end, rest] = readValue(rest, ['=', ',']);\n      if (end === '=') {\n        [val, end, rest] = readValue(rest, [',']);\n        val = (val === 'false' || val === 'true') ?\n            JSON.parse(val) : val;\n        options[key] = val;\n      } else if (key) {\n        options[key] = true;\n      }\n    }\n    return options;\n  }\n\n\n  /**\n   * Removes pairs of outer braces.\n   * @param {string} text The string to clean.\n   * @param {number} count The number of outer braces to slice off.\n   * @return {string} The cleaned string.\n   */\n  function removeBraces(text: string, count: number): string {\n    while (count > 0) {\n      text = text.trim().slice(1, -1);\n      count--;\n    }\n    return text.trim();\n  }\n\n\n  /**\n   * Read a value from the given string until an end parameter is reached or\n   * string is exhausted.\n   * @param {string} text The string to process.\n   * @param {string[]} end List of possible end characters.\n   * @return {[string, string, string]} The collected value, the actual end\n   *     character, and the rest of the string still to parse.\n   */\n  function readValue(text: string, end: string[]): [string, string, string] {\n    let length = text.length;\n    let braces = 0;\n    let value = '';\n    let index = 0;\n    let start = 0;             // Counter for the starting left braces.\n    let startCount = true;     // Flag for counting starting left braces.\n    let stopCount = false;     // If true right braces are found directly\n                               // after starting braces, but no other char yet.\n    while (index < length) {\n      let c = text[index++];\n      switch (c) {\n      case ' ':                // Ignore spaces.\n        break;\n      case '{':\n        if (startCount) {      // Count start left braces at start.\n          start++;\n        } else {\n          stopCount = false;\n          if (start > braces) {   // Some start left braces have been closed.\n            start = braces;\n          }\n        }\n        braces++;\n        break;\n      case '}':\n        if (braces) {          // Closing braces.\n          braces--;\n        }\n        if (startCount || stopCount) {  // Closing braces at the start.\n          start--;\n          stopCount = true;    // Continue to close braces.\n        }\n        startCount = false;    // Stop counting start left braces.\n        break;\n      default:\n        if (!braces && end.indexOf(c) !== -1) {   // End character reached.\n          return [stopCount ? 'true' :            // If Stop count is true we\n                                                  // have balanced braces, only.\n                  removeBraces(value, start), c, text.slice(index)];\n        }\n        startCount = false;\n        stopCount = false;\n      }\n      value += c;\n    }\n    if (braces) {\n      throw new TexError('ExtraOpenMissingClose',\n                         'Extra open brace or missing close brace');\n    }\n    return [stopCount ? 'true' : removeBraces(value, start), '', text.slice(index)];\n  }\n\n}\n\nexport default ParseUtil;\n","/*************************************************************\n *\n *  Copyright (c) 2009-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview The Stack for the TeX parser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport NodeUtil from './NodeUtil.js';\nimport {MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {StackItem, EnvList} from './StackItem.js';\nimport StackItemFactory from './StackItemFactory.js';\n\n\nexport default class Stack {\n\n  /**\n   * @type {EnvList}\n   */\n  public global: EnvList = {};\n\n  /**\n   * The actual stack, a list of stack items.\n   * @type {Array.<StackItem>}\n   */\n  private stack: StackItem[] = [];\n\n  /**\n   * @constructor\n   * @param {StackItemFactory} factory The stack item factory.\n   * @param {EnvList} env The environment.\n   * @param {boolean} inner True if parser has been called recursively.\n   */\n  constructor(private _factory: StackItemFactory,\n              private _env: EnvList, inner: boolean) {\n    this.global = {isInner: inner};\n    this.stack = [ this._factory.create('start', this.global) ];\n    if (_env) {\n      this.stack[0].env = _env;\n    }\n    this.env = this.stack[0].env;\n  }\n\n\n  /**\n   * Set the environment of the stack.\n   * @param {EnvList} env The new environment.\n   */\n  public set env(env: EnvList) {\n    this._env = env;\n  }\n\n\n  /**\n   * Retrieves the environment of that stack.\n   * @return {EnvList} The current environment.\n   */\n  public get env(): EnvList {\n    return this._env;\n  }\n\n\n  /**\n   * Pushes items or nodes onto stack.\n   * @param {...StackItem|MmlNode} args A list of items to push.\n   */\n  public Push(...args: (StackItem | MmlNode)[]) {\n    for (const node of args) {\n      if (!node) {\n        continue;\n      }\n      const item = NodeUtil.isNode(node) ?\n        this._factory.create('mml', node) : node as StackItem;\n      item.global = this.global;\n      const [top, success] =\n        this.stack.length ? this.Top().checkItem(item) : [null, true];\n      if (!success) {\n        continue;\n      }\n      if (top) {\n        this.Pop();\n        this.Push(...top);\n        continue;\n      }\n      this.stack.push(item);\n      if (item.env) {\n        if (item.copyEnv) {\n          Object.assign(item.env, this.env);\n        }\n        this.env = item.env;\n      } else {\n        item.env = this.env;\n      }\n    }\n  }\n\n\n  /**\n   * Pop the topmost elements off the stack.\n   * @return {StackItem} A stack item.\n   */\n  public Pop(): StackItem {\n    const item = this.stack.pop();\n    if (!item.isOpen) {\n      delete item.env;\n    }\n    this.env = (this.stack.length ? this.Top().env : {});\n    return item;\n  }\n\n\n  /**\n   * Lookup the nth elements on the stack without removing them.\n   * @param {number=} n Position of element that should be returned. Default 1.\n   * @return {StackItem} Nth item on the stack.\n   */\n  public Top(n: number = 1): StackItem {\n    return this.stack.length < n ? null : this.stack[this.stack.length - n];\n  }\n\n\n  /**\n   * Lookup the topmost element on the stack, returning the Mml node in that\n   * item. Optionally pops the Mml node from that stack item.\n   * @param {boolean=} noPop Pop top item if true.\n   * @return {MmlNode} The Mml node in the topmost stack item.\n   */\n  public Prev(noPop?: boolean): MmlNode | void {\n    const top = this.Top();\n    return noPop ? top.First : top.Pop();\n  }\n\n\n  /**\n   * @override\n   */\n  public toString() {\n    return 'stack[\\n  ' + this.stack.join('\\n  ') + '\\n]';\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Symbol classes.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {Args, Attributes, ParseMethod} from './Types.js';\n\n\n/**\n * Symbol class\n */\nexport class Symbol {\n\n  /**\n   * @constructor\n   * @param {string} symbol The symbol parsed.\n   * @param {string} char The corresponding translation.\n   * @param {Attributes} attributes The attributes for the translation.\n   */\n  constructor(private _symbol: string, private _char: string,\n              private _attributes: Attributes) {\n  }\n\n  public get symbol(): string {\n    return this._symbol;\n  }\n\n  public get char(): string {\n    return this._char;\n  }\n\n  public get attributes(): Attributes {\n    return this._attributes;\n  }\n\n}\n\n\nexport class Macro {\n\n  /**\n   * @constructor\n   * @param {string} symbol The symbol parsed\n   * @param {ParseMethod} func The parsing function for that symbol.\n   * @param {Args[]} args Additional arguments for the function.\n   */\n  constructor(private _symbol: string, private _func: ParseMethod,\n              private _args: Args[] = []) {\n  }\n\n  public get symbol(): string {\n    return this._symbol;\n  }\n\n  public get func(): ParseMethod {\n    return this._func;\n  }\n\n  public get args(): Args[] {\n    return this._args;\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Symbol map classes.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {Attributes, Args, ParseMethod, ParseInput, ParseResult} from './Types.js';\nimport {Symbol, Macro} from './Symbol.js';\nimport {MapHandler} from './MapHandler.js';\n\n\n/**\n * SymbolMaps are the base components for the input parsers.\n *\n * They provide a contains method that checks if a map is applicable (contains)\n * a particular string. Implementing classes then perform the actual symbol\n * parsing, from simple regular expression test, straight forward symbol mapping\n * to transformational functionality on the parsed string.\n *\n * @interface\n */\nexport interface SymbolMap {\n\n  /**\n   * @return {string} The name of the map.\n   */\n  name: string;\n\n  /**\n   * @return {ParseMethod} The default parsing method.\n   */\n  parser: ParseMethod;\n\n  /**\n   * @param {string} symbol A symbol to parse.\n   * @return {boolean} True if the symbol map applies to the symbol.\n   */\n  contains(symbol: string): boolean;\n\n  /**\n   * @param {string} symbol A symbol to parse.\n   * @return {ParseMethod} A parse method for the symbol.\n   */\n  parserFor(symbol: string): ParseMethod;\n\n  /**\n   * @param {TexParser} env The current parser.\n   * @param {string} symbol A symbol to parse.\n   * @return {ParseResult} The parsed symbol and the rest of the string.\n   */\n  parse([env, symbol]: ParseInput): ParseResult;\n\n}\n\n/**\n * @param {ParseResult} result    The result to check\n * @return {ParseResult}          True if result was void, result otherwise\n */\nexport function parseResult(result: ParseResult): ParseResult {\n  return result === void 0 ? true : result;\n}\n\n/**\n * Abstract implementation of symbol maps.\n * @template T\n */\nexport abstract class AbstractSymbolMap<T> implements SymbolMap {\n\n  /**\n   * @constructor\n   * @implements {SymbolMap}\n   * @param {string} name Name of the mapping.\n   * @param {ParseMethod} parser The parser for the mappiong.\n   */\n  constructor(private _name: string, private _parser: ParseMethod) {\n    MapHandler.register(this);\n  }\n\n\n  /**\n   * @override\n   */\n  public get name(): string {\n    return this._name;\n  }\n\n\n  /**\n   * @override\n   */\n  public abstract contains(symbol: string): boolean;\n\n\n  /**\n   * @override\n   */\n  public parserFor(symbol: string) {\n    return this.contains(symbol) ? this.parser : null;\n  }\n\n\n  /**\n   * @override\n   */\n  public parse([env, symbol]: ParseInput) {\n    let parser = this.parserFor(symbol);\n    let mapped = this.lookup(symbol);\n    return (parser && mapped) ? parseResult(parser(env, mapped as any)) : null;\n  }\n\n\n  public set parser(parser: ParseMethod) {\n    this._parser = parser;\n  }\n\n  public get parser(): ParseMethod {\n    return this._parser;\n  }\n\n\n  /**\n   * @param {string} symbol\n   * @return {T}\n   */\n  public abstract lookup(symbol: string): T;\n\n}\n\n\n\n/**\n * Regular expressions used for parsing strings.\n */\nexport class RegExpMap extends AbstractSymbolMap<string> {\n\n  /**\n   * @constructor\n   * @extends {AbstractSymbolMap}\n   * @param {string} name Name of the mapping.\n   * @param {ParseMethod} parser The parser for the mappiong.\n   * @param {RegExp} regexp The regular expression.\n   */\n  constructor(name: string, parser: ParseMethod, private _regExp: RegExp) {\n    super(name, parser);\n  }\n\n\n  /**\n   * @override\n   */\n  public contains(symbol: string) {\n    return this._regExp.test(symbol);\n  }\n\n\n  /**\n   * @override\n   */\n  public lookup(symbol: string): string {\n    return this.contains(symbol) ? symbol : null;\n  }\n\n}\n\n\n/**\n * Parse maps associate strings with parsing functionality.\n * @constructor\n * @extends {AbstractSymbolMap}\n * @template K\n */\nexport abstract class AbstractParseMap<K> extends AbstractSymbolMap<K> {\n\n  private map: Map<string, K> = new Map<string, K>();\n\n  /**\n   * @override\n   */\n  public lookup(symbol: string): K {\n    return this.map.get(symbol);\n  }\n\n  /**\n   * @override\n   */\n  public contains(symbol: string) {\n    return this.map.has(symbol);\n  }\n\n  /**\n   * Sets mapping for a symbol.\n   * @param {string} symbol The symbol to map.\n   * @param {K} object The symbols value in the mapping's codomain.\n   */\n  public add(symbol: string, object: K) {\n    this.map.set(symbol, object);\n  }\n\n  /**\n   * Removes a symbol from the map\n   * @param {string} symbol The symbol to remove\n   */\n  public remove(symbol: string) {\n    this.map.delete(symbol);\n  }\n\n}\n\n\n/**\n * Maps symbols that can all be parsed with the same method.\n *\n * @constructor\n * @extends {AbstractParseMap}\n */\nexport class CharacterMap extends AbstractParseMap<Symbol> {\n\n  /**\n   * @constructor\n   * @param {string} name Name of the mapping.\n   * @param {ParseMethod} parser The parser for the mapping.\n   * @param {JSON} json The JSON representation of the character mapping.\n   */\n  constructor(name: string, parser: ParseMethod,\n              json: {[index: string]: string | [string, Attributes]}) {\n    super(name, parser);\n    for (const key of Object.keys(json)) {\n      let value = json[key];\n      let [char, attrs] = (typeof(value) === 'string') ? [value, null] : value;\n      let character = new Symbol(key, char, attrs);\n      this.add(key, character);\n    }\n  }\n\n}\n\n\n/**\n * Maps symbols that are delimiters, that are all parsed with the same method.\n *\n * @constructor\n * @extends {CharacterMap}\n */\nexport class DelimiterMap extends CharacterMap {\n\n  /**\n   * @override\n   */\n  public parse([env, symbol]: ParseInput) {\n    return super.parse([env, '\\\\' + symbol]);\n  }\n\n}\n\n\n/**\n * Maps macros that all bring their own parsing method.\n *\n * @constructor\n * @extends {AbstractParseMap}\n */\nexport class MacroMap extends AbstractParseMap<Macro> {\n\n  /**\n   * @constructor\n   * @param {string} name Name of the mapping.\n   * @param {JSON} json The JSON representation of the macro map.\n   * @param {Record<string, ParseMethod>} functionMap Collection of parse\n   *     functions for the single macros.\n   */\n  constructor(name: string,\n              json: {[index: string]: string | Args[]},\n              functionMap: Record<string, ParseMethod>) {\n    super(name, null);\n    for (const key of Object.keys(json)) {\n      let value = json[key];\n      let [func, ...attrs] = (typeof(value) === 'string') ? [value] : value;\n      let character = new Macro(key, functionMap[func as string], attrs);\n      this.add(key, character);\n    }\n  }\n\n\n  /**\n   * @override\n   */\n  public parserFor(symbol: string) {\n    let macro = this.lookup(symbol);\n    return macro ? macro.func : null;\n  }\n\n\n  /**\n   * @override\n   */\n  public parse([env, symbol]: ParseInput) {\n    let macro = this.lookup(symbol);\n    let parser = this.parserFor(symbol);\n    if (!macro || !parser) {\n      return null;\n    }\n    return parseResult(parser(env, macro.symbol, ...macro.args));\n  }\n\n}\n\n\n/**\n * Maps macros that all bring their own parsing method.\n *\n * @constructor\n * @extends {MacroMap}\n */\nexport class CommandMap extends MacroMap {\n\n  /**\n   * @override\n   */\n  public parse([env, symbol]: ParseInput) {\n    let macro = this.lookup(symbol);\n    let parser = this.parserFor(symbol);\n    if (!macro || !parser) {\n      return null;\n    }\n    let saveCommand = env.currentCS;\n    env.currentCS = '\\\\' + symbol;\n    let result = parser(env, '\\\\' + macro.symbol, ...macro.args);\n    env.currentCS = saveCommand;\n    return parseResult(result);\n  }\n\n}\n\n\n/**\n * Maps macros for environments. It has a general parsing method for\n * environments, i.e., one that deals with begin/end, and each environment has\n * its own parsing method returning the content.\n *\n * @constructor\n * @extends {MacroMap}\n */\nexport class EnvironmentMap extends MacroMap {\n\n  /**\n   * @constructor\n   * @param {string} name Name of the mapping.\n   * @param {ParseMethod} parser The parser for the environments.\n   * @param {JSON} json The JSON representation of the macro map.\n   * @param {Record<string, ParseMethod>} functionMap Collection of parse\n   *     functions for the single macros.\n   */\n  constructor(name: string,\n              parser: ParseMethod,\n              json: {[index: string]: string | Args[]},\n              functionMap: Record<string, ParseMethod>) {\n    super(name, json, functionMap);\n    this.parser = parser;\n  }\n\n\n  /**\n   * @override\n   */\n  public parse([env, symbol]: ParseInput) {\n    let macro = this.lookup(symbol);\n    let envParser = this.parserFor(symbol);\n    if (!macro || !envParser) {\n      return null;\n    }\n    return parseResult(this.parser(env, macro.symbol, envParser, macro.args));\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Class for generating tags, references, etc.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport TexParser from './TexParser.js';\nimport {MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {MathItem} from '../../core/MathItem.js';\nimport {EnvList} from './StackItem.js';\nimport ParseOptions from './ParseOptions.js';\nimport {OptionList} from '../../util/Options.js';\n\n\n/**\n *  Simple class for label objects.\n */\nexport class Label {\n\n  /**\n   * @constructor\n   * @param {string=} tag The tag that's displayed.\n   * @param {string=} id The id that serves as reference.\n   */\n  constructor(public tag: string = '???', public id: string = '') {}\n}\n\n\n/**\n * A simple class for keeping track of tag information.\n */\nexport class TagInfo {\n\n  /**\n   * @constructor\n   * @param {string} env The environment name (e.g., align).\n   * @param {boolean} taggable Environment supports tags (e.g., align* does, but\n   *     split does not.)\n   * @param {boolean} defaultTags Environment is tagged by default (e.g., align\n   *     is, but align* is not).\n   * @param {string} tag The tag name (e.g., 1).\n   * @param {string} tagId The unique id for that tag (e.g., mjx-eqn:1).\n   * @param {string} tagFormat The formatted tag (e.g., \"(1)\").\n   * @param {boolean} noTag A no tagging command has been set (e.g., \\notag,\n   *     \\nonumber).\n   * @param {string} labelId The label referring to the tag.\n   */\n  constructor(readonly env: string = '',\n              readonly taggable: boolean = false,\n              readonly defaultTags: boolean = false,\n              public tag: string = null,\n              public tagId: string = '',\n              public tagFormat: string = '',\n              public noTag: boolean = false,\n              public labelId: string = '') {}\n\n}\n\n\nexport interface Tags {\n\n  /**\n   * The global configurations in which the parsing takes place.\n   * @type {ParseOptions}\n   */\n  configuration: ParseOptions;\n\n  /**\n   * IDs used in this equation.\n   * @type {Object.<boolean>}\n   */\n  ids: {[key: string]: boolean};\n\n  /**\n   * IDs used in previous equations.\n   * @type {Object.<boolean>}\n   */\n  allIds: {[key: string]: boolean};\n\n  /**\n   * Labels in the current equation.\n   * @type {Object.<Label>}\n   */\n  labels: {[key: string]: Label};\n\n  /**\n   * Labels in previous equations.\n   * @type {Object.<Label>}\n   */\n  allLabels: {[key: string]: Label};\n\n  /**\n   * The label to use for the next tag.\n   * @type {string}\n   */\n  label: string;\n\n  /**\n   * True if the equation contains an undefined label and must be reprocessed later.\n   * @type {boolean}\n   */\n  redo: boolean;\n\n  /**\n   * True when recompiling to update undefined references\n   * @type {boolean}\n   */\n  refUpdate: boolean;\n\n  /**\n   * The environment that is currently tagged.\n   * @type {string}\n   */\n  env: string;\n\n  /**\n   * The currently active tag.\n   * @type {TagInfo}\n   */\n  currentTag: TagInfo;\n\n  /**\n   * How to format tags.\n   * @param {string} tag The tag string.\n   * @return {string} The formatted numbered tag.\n   */\n  formatTag(tag: string): string;\n\n  /**\n   * How to format URLs for references.\n   * @param {string} id The reference id.\n   * @param {string} base The base URL in the reference.\n   * @return {}\n   */\n  formatUrl(id: string, base: string): string;\n\n  /**\n   * Set the tag automatically, by incrementing equation number.\n   */\n  autoTag(): void;\n\n  /**\n   * @return {MmlNode|void} Generates and returns the tag node.\n   */\n  getTag(): MmlNode | void;\n\n  /**\n   * Clears tagging information.\n   */\n  clearTag(): void;\n\n  /**\n   * Resets the tag structure after an expression has been typeset.\n   */\n  resetTag(): void;\n\n  /**\n   * Fully resets the tag structure, in particular all the tagging and label\n   * history.\n   * @param {number} offset A new offset value to start counting ids from.\n   */\n  reset(offset?: number): void;\n\n  /**\n   * Initialise tagging for a MathItem\n   * (clear equation-specific labels and ids, set counter\n   * and check for recompile)\n   * @param {MathItem} math   The MathItem for the current equation\n   */\n    startEquation(math: MathItem<any, any, any>): void;\n\n  /**\n   * Move equation-specific labels and ids to global ones,\n   * save the counter, and mark the MathItem for redos\n   */\n    finishEquation(math: MathItem<any, any, any>): void;\n\n  /**\n   * Finalizes tag creation.\n   * @param {MmlNode} node\n   * @param {EnvList} env List of environment properties.\n   * @return {MmlNode} The newly created tag.\n   */\n  finalize(node: MmlNode, env: EnvList): MmlNode;\n\n  /**\n   * Starts tagging on a given environment.\n   * @param {string} env The name of the environment.\n   * @param {boolean} taggable True if taggable.\n   * @param {boolean} defaultTags True if tagged by default.\n   */\n  start(env: string, taggable: boolean, defaultTags: boolean): void;\n\n  /**\n   * End tagging.\n   */\n  end(): void;\n\n  /**\n   * Computes the next tag.\n   * @param {string} tag The tag content.\n   * @param {boolean} noFormat True if tag should not be formatted.\n   */\n  tag(tag: string, noFormat: boolean): void;\n\n  /**\n   * Call an explicit no tag.\n   */\n  notag(): void;\n\n  /**\n   * Entag an element by creating a table around it.\n   * @param {MmlNode} node The node to be tagged.\n   * @param {MmlNode} tag The tag node.\n   * @return {MmlNode} The table node containing the original node and tag.\n   */\n  enTag(node: MmlNode, tag: MmlNode): MmlNode;\n}\n\n\nexport class AbstractTags implements Tags {\n\n  /**\n   * Current equation number.\n   * @type {number}\n   */\n  protected counter: number = 0;\n\n  /**\n   * Equation number as equation begins.\n   * @type {number}\n   */\n  protected allCounter: number = 0;\n\n  /**\n   * @override\n   */\n  public configuration: ParseOptions = null;\n\n  /**\n   * @override\n   */\n  public ids: {[key: string]: boolean} = {};\n\n  /**\n   * @override\n   */\n  public allIds: {[key: string]: boolean} = {};\n\n  /**\n   * @override\n   */\n  public labels: {[key: string]: Label} = {};\n\n  /**\n   * @override\n   */\n  public allLabels: {[key: string]: Label} = {};\n\n  /**\n   * @override\n   */\n  public redo: boolean = false;\n\n  /**\n   * @override\n   */\n  public refUpdate: boolean = false;\n\n  /**\n   * @override\n   */\n  public currentTag: TagInfo = new TagInfo();\n\n\n  /**\n   * Chronology of all previous tags, in case we need to look something up in\n   * the finalize method.\n   * @type {TagInfo[]}\n   */\n  protected history: TagInfo[] = [];\n\n  private stack: TagInfo[] = [];\n\n  /**\n   * @override\n   */\n  public start(env: string, taggable: boolean, defaultTags: boolean) {\n    if (this.currentTag) {\n      this.stack.push(this.currentTag);\n    }\n    this.currentTag = new TagInfo(env, taggable, defaultTags);\n  }\n\n  public get env() {\n    return this.currentTag.env;\n  }\n\n\n  /**\n   * @override\n   */\n  public end() {\n    this.history.push(this.currentTag);\n    this.currentTag = this.stack.pop();\n  }\n\n\n  /**\n   * @override\n   */\n  public tag(tag: string, noFormat: boolean) {\n    this.currentTag.tag = tag;\n    this.currentTag.tagFormat = noFormat ? tag : this.formatTag(tag);\n    this.currentTag.noTag = false;\n  }\n\n\n  /**\n   * @override\n   */\n  public notag() {\n    this.tag('', true);\n    this.currentTag.noTag = true;\n  }\n\n  protected get noTag(): boolean {\n    return this.currentTag.noTag;\n  }\n\n  public set label(label: string) {\n    this.currentTag.labelId = label;\n  }\n\n  public get label() {\n    return this.currentTag.labelId;\n  }\n\n  /**\n   * @override\n   */\n  public formatUrl(id: string, base: string) {\n    return base + '#' + encodeURIComponent(id);\n  }\n\n  /**\n   * @override\n   */\n  public formatTag(tag: string) {\n    return '(' + tag + ')';\n  }\n\n  /**\n   * How to format ids for labelling equations.\n   * @param {string} id The unique part of the id (e.g., label or number).\n   * @return {string} The formatted id.\n   */\n  protected formatId(id: string): string {\n    return 'mjx-eqn:' + id.replace(/\\s/g, '_');\n  }\n\n  /**\n   * How to format numbers in tags.\n   * @param {number} n The tag number.\n   * @return {string} The formatted number.\n   */\n  protected formatNumber(n: number): string {\n    return n.toString();\n  }\n\n  // Tag handling functions.\n  /**\n   * @override\n   */\n  public autoTag() {\n    if (this.currentTag.tag == null) {\n      this.counter++;\n      this.tag(this.formatNumber(this.counter), false);\n    }\n  }\n\n\n  /**\n   * @override\n   */\n  public clearTag() {\n    this.label = '';\n    this.tag(null, true);\n    this.currentTag.tagId = '';\n  }\n\n\n  /**\n   * @override\n   */\n  public getTag(force: boolean = false) {\n    if (force) {\n      this.autoTag();\n      return this.makeTag();\n    }\n    const ct = this.currentTag;\n    if (ct.taggable && !ct.noTag) {\n      if (ct.defaultTags) {\n        this.autoTag();\n      }\n      if (ct.tag) {\n        return this.makeTag();\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * @override\n   */\n  public resetTag() {\n    this.history = [];\n    this.redo = false;\n    this.refUpdate = false;\n    this.clearTag();\n  }\n\n  /**\n   * @override\n   */\n  public reset(offset: number = 0) {\n    this.resetTag();\n    this.counter = this.allCounter = offset;\n    this.allLabels = {};\n    this.allIds = {};\n  }\n\n  /**\n   * @override\n   */\n  public startEquation(math: MathItem<any, any, any>) {\n    this.history = [];\n    this.stack = [];\n    this.clearTag();\n    this.currentTag = new TagInfo('', undefined, undefined);\n    this.labels = {};\n    this.ids = {};\n    this.counter = this.allCounter;\n    this.redo = false;\n    const recompile = math.inputData.recompile;\n    if (recompile) {\n      this.refUpdate = true;\n      this.counter = recompile.counter;\n    }\n  }\n\n  /**\n   * @override\n   */\n  public finishEquation(math: MathItem<any, any, any>) {\n    if (this.redo) {\n      math.inputData.recompile = {\n        state: math.state(),\n        counter: this.allCounter\n      };\n    }\n    if (!this.refUpdate) {\n      this.allCounter = this.counter;\n    }\n    Object.assign(this.allIds, this.ids);\n    Object.assign(this.allLabels, this.labels);\n  }\n\n  /**\n   * @override\n   */\n  public finalize(node: MmlNode, env: EnvList): MmlNode {\n    if (!env.display || this.currentTag.env ||\n        this.currentTag.tag == null) {\n      return node;\n    }\n    let tag = this.makeTag();\n    let table = this.enTag(node, tag);\n    return table;\n  }\n\n  /**\n   * @override\n   */\n  public enTag = function(node: MmlNode, tag: MmlNode): MmlNode {\n    let nf = this.configuration.nodeFactory;\n    let cell = nf.create('node', 'mtd', [node]);\n    let row = nf.create('node', 'mlabeledtr', [tag, cell]);\n    let table = nf.create('node', 'mtable', [row], {\n      side: this.configuration.options['tagSide'],\n      minlabelspacing: this.configuration.options['tagIndent'],\n      displaystyle: true\n    });\n    return table;\n  };\n\n\n  /**\n   * Sets the tag id.\n   */\n  private makeId() {\n    this.currentTag.tagId = this.formatId(\n      this.configuration.options['useLabelIds'] ?\n        (this.label || this.currentTag.tag) : this.currentTag.tag);\n  }\n\n\n  /**\n   * @return {MmlNode} The actual tag node as an mtd.\n   */\n  private makeTag(): MmlNode {\n    this.makeId();\n    if (this.label) {\n      this.labels[this.label] = new Label(this.currentTag.tag, this.currentTag.tagId);\n    }\n    let mml = new TexParser('\\\\text{' + this.currentTag.tagFormat + '}', {},\n                            this.configuration).mml();\n    return this.configuration.nodeFactory.create('node', 'mtd', [mml],\n                                                 {id: this.currentTag.tagId});\n  }\n\n}\n\n\n/**\n * No tags, except where explicitly set.\n * @constructor\n * @extends {AbstractTags}\n */\nexport class NoTags extends AbstractTags {\n\n  /**\n   * @override\n   */\n  public autoTag() {}\n\n  /**\n   * @override\n   */\n  public getTag() {\n    return !this.currentTag.tag ? null : super.getTag();\n  }\n\n}\n\n\n/**\n * Tags every display formula. Exceptions are: Environments that explicitly\n * disallow tags, e.g., equation*.\n * @constructor\n * @extends {AbstractTags}\n */\nexport class AllTags extends AbstractTags {\n\n  /**\n   * @override\n   */\n  public finalize(node: MmlNode, env: EnvList) {\n    if (!env.display || this.history.find(\n      function(x: TagInfo) { return x.taggable; })) {\n      return node;\n    }\n    let tag = this.getTag(true);\n    return this.enTag(node, tag);\n  }\n\n}\n\n\n/**\n * Class interface for factory.\n * @interface\n */\nexport interface TagsClass {\n  new (): Tags;\n}\n\n\nexport namespace TagsFactory {\n\n  let tagsMapping = new Map<string, TagsClass>([\n    ['none', NoTags],\n    ['all', AllTags]\n  ]);\n\n  let defaultTags = 'none';\n\n  /**\n   * The default options for tagging\n   * @type {OptionList}\n   */\n  export let OPTIONS: OptionList = {\n    // Tagging style, used to be autonumber in v2.\n    tags: defaultTags,\n    // This specifies the side on which \\tag{} macros will place the tags.\n    // Set to 'left' to place on the left-hand side.\n    tagSide: 'right',\n    // This is the amount of indentation (from right or left) for the tags.\n    tagIndent: '0.8em',\n    // make element ID's use \\label name rather than equation number\n    // MJ puts in an equation prefix: mjx-eqn\n    // When true it uses the label name XXX as mjx-eqn:XXX\n    // If false it uses the actual number N that is displayed: mjx-eqn:N\n    useLabelIds: true,\n    // Set to true in order to prevent error messages for duplicate label ids\n    ignoreDuplicateLabels: false\n  };\n\n\n  /**\n   * Add a tagging object.\n   * @param {string} name Name of the tagging object.\n   * @param {TagsClass} constr The class of the Tagging object.\n   */\n  export let add = function(name: string, constr: TagsClass) {\n    tagsMapping.set(name, constr);\n  };\n\n\n  /**\n   * Adds a list of tagging objects to the factory.\n   * @param {{[name: string]: TagsClass}} tags The list of tagging objects.\n   */\n  export let addTags = function(tags: {[name: string]: TagsClass}) {\n    for (const key of Object.keys(tags)) {\n      TagsFactory.add(key, tags[key]);\n    }\n  };\n\n\n  /**\n   * Creates a new tagging object.\n   * @param {string} name The name of the tagging object.\n   * @return {Tags} The newly created object.\n   */\n  export let create = function(name: string): Tags {\n    let constr = tagsMapping.get(name) || tagsMapping.get(defaultTags);\n    if (!constr) {\n        throw Error('Unknown tags class');\n    }\n    return new constr();\n  };\n\n\n  /**\n   * Set the name of the default tagging object.\n   * @param {string} name The default.\n   */\n  export let setDefault = function(name: string) {\n    defaultTags = name;\n  };\n\n\n  /**\n   * @return {Tags} The default tagging object.\n   */\n  export let getDefault = function(): Tags {\n    return TagsFactory.create(defaultTags);\n  };\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2009-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Error class for the TeX parser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\n\nexport default class TexError {\n\n  private static pattern =\n    /%(\\d+|\\{\\d+\\}|\\{[a-z]+:\\%\\d+(?:\\|(?:%\\{\\d+\\}|%.|[^\\}])*)+\\}|.)/g;\n\n  /**\n   * Default error message.\n   * @type {string}\n   */\n  public message: string;\n\n  /**\n   * The old MathJax processing function.\n   * @param {string} str The basic error message.\n   * @param {string[]} args The arguments to be replaced in the error message.\n   * @return {string} The processed error string.\n   */\n  private static processString(str: string, args: string[]): string {\n    let parts = str.split(TexError.pattern);\n    for (let i = 1, m = parts.length; i < m; i += 2) {\n      let c = parts[i].charAt(0);  // first char will be { or \\d or a char to be\n                                   // kept literally\n      if (c >= '0' && c <= '9') {    // %n\n        parts[i] = args[parseInt(parts[i], 10) - 1];\n        if (typeof parts[i] === 'number') {\n          parts[i] = parts[i].toString();\n        }\n      } else if (c === '{') {        // %{n} or %{plural:%n|...}\n        c = parts[i].substr(1);\n        if (c >= '0' && c <= '9') {  // %{n}\n          parts[i] = args[parseInt(parts[i].substr(1, parts[i].length - 2), 10) - 1];\n          if (typeof parts[i] === 'number') {\n            parts[i] = parts[i].toString();\n          }\n        } else {                     // %{plural:%n|...}\n          let match = parts[i].match(/^\\{([a-z]+):%(\\d+)\\|(.*)\\}$/);\n          if (match) {\n            // Removed plural here.\n            parts[i] = '%' + parts[i];\n          }\n        }\n      }\n      if (parts[i] == null) {\n        parts[i] = '???';\n      }\n    }\n    return parts.join('');\n  }\n\n  /**\n   * @constructor\n   * @param{string} id        message id (for localization)\n   * @param{string} message   text of English message\n   * @param{string[]=} rest   any substitution arguments\n   */\n  constructor(public id: string, message: string, ...rest: string[]) {\n    this.message = TexError.processString(message, rest);\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview The TexParser. Implements the basic parsing functionality and\n *     administers the global stack and tree objects.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport ParseUtil from './ParseUtil.js';\nimport {HandlerType} from './MapHandler.js';\nimport Stack from './Stack.js';\nimport StackItemFactory from './StackItemFactory.js';\nimport {Tags} from './Tags.js';\nimport TexError from './TexError.js';\nimport {MmlNode, AbstractMmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {ParseInput, ParseResult} from './Types.js';\nimport ParseOptions from './ParseOptions.js';\nimport {StackItem, EnvList} from './StackItem.js';\nimport {Symbol} from './Symbol.js';\nimport {OptionList} from '../../util/Options.js';\n\n\n/**\n * The main Tex Parser class.\n */\nexport default class TexParser {\n\n  /**\n   * Counter for recursive macros.\n   * @type {number}\n   */\n  public macroCount: number = 0;\n\n  /**\n   * The stack for items and created nodes.\n   * @type {Stack}\n   */\n  public stack: Stack;\n\n  /**\n   * Current position in the string that is parsed.\n   * @type {number}\n   */\n  public i: number = 0;\n\n  /**\n   * The last command sequence\n   * @type {string}\n   */\n  public currentCS: string = '';\n\n  /**\n   * @constructor\n   * @param {string} string The string to parse.\n   * @param {EnvList} env The intial environment representing the current parse\n   *     state of the overall expression translation.\n   * @param {ParseOptions} configuration A parser configuration.\n   */\n  constructor(private _string: string, env: EnvList, public configuration: ParseOptions) {\n    const inner = env.hasOwnProperty('isInner');\n    const isInner = env['isInner'] as boolean;\n    delete env['isInner'];\n    let ENV: EnvList;\n    if (env) {\n      ENV = {};\n      for (const id of Object.keys(env)) {\n        ENV[id] = env[id];\n      }\n    }\n    this.configuration.pushParser(this);\n    this.stack = new Stack(this.itemFactory, ENV, inner ? isInner : true);\n    this.Parse();\n    this.Push(this.itemFactory.create('stop'));\n  }\n\n  /**\n   * @return {OptionList} The configuration options.\n   */\n  get options(): OptionList {\n    return this.configuration.options;\n  }\n\n  /**\n   * @return {StackItemFactory} The factory for stack items.\n   */\n  get itemFactory(): StackItemFactory {\n    return this.configuration.itemFactory;\n  }\n\n  /**\n   * @return {Tags} The tags style of this configuration.\n   */\n  get tags(): Tags {\n    return this.configuration.tags;\n  }\n\n  /**\n   * Sets the string that should be parsed.\n   * @param {string} str The new string to parse.\n   */\n  set string(str: string) {\n    this._string = str;\n  }\n\n  /**\n   * @return {string} The string that is currently parsed.\n   */\n  get string(): string {\n    return this._string;\n  }\n\n\n  /**\n   * Parses the input with the specified kind of map.\n   * @param {HandlerType} kind Configuration name.\n   * @param {ParseInput} input Input to be parsed.\n   * @return {ParseResult} The output of the parsing function.\n   */\n  public parse(kind: HandlerType, input: ParseInput): ParseResult {\n    return this.configuration.handlers.get(kind).parse(input);\n  }\n\n\n  /**\n   * Maps a symbol to its \"parse value\" if it exists.\n   * @param {HandlerType} kind Configuration name.\n   * @param {string} symbol The symbol to parse.\n   * @return {any} A boolean, Character, or Macro.\n   */\n  public lookup(kind: HandlerType, symbol: string): any {\n    return this.configuration.handlers.get(kind).lookup(symbol);\n  }\n\n\n  /**\n   * Checks if a symbol is contained in one of the symbol mappings of the\n   * specified kind.\n   * @param {HandlerType} kind Configuration name.\n   * @param {string} symbol The symbol to parse.\n   * @return {boolean} True if the symbol is contained in the given types of\n   *     symbol mapping.\n   */\n  public contains(kind: HandlerType, symbol: string): boolean {\n    return this.configuration.handlers.get(kind).contains(symbol);\n  }\n\n\n  /**\n   * @override\n   */\n  public toString(): string {\n    let str = '';\n    for (const config of Array.from(this.configuration.handlers.keys())) {\n      str += config + ': ' +\n        this.configuration.handlers.get(config as HandlerType) + '\\n';\n    }\n    return str;\n  }\n\n\n  /**\n   * Parses the current input string.\n   */\n  public Parse() {\n    let c: string;\n    while (this.i < this.string.length) {\n      c = this.getCodePoint();\n      this.i += c.length;\n      this.parse('character', [this, c]);\n    }\n  }\n\n\n  /**\n   * Pushes a new item onto the stack. The item can also be a Mml node,\n   *   but if the mml item is an inferred row, push its children instead.\n   * @param {StackItem|MmlNode} arg The new item.\n   */\n  public Push(arg: StackItem | MmlNode) {\n    if (arg instanceof AbstractMmlNode && arg.isInferred) {\n      this.PushAll(arg.childNodes);\n    } else {\n      this.stack.Push(arg);\n    }\n  }\n\n\n  /**\n   * Pushes a list of new items onto the stack.\n   * @param {StackItem|MmlNode[]} args The new items.\n   */\n  public PushAll(args: (StackItem | MmlNode)[]) {\n    for (const arg of args) {\n      this.stack.Push(arg);\n    }\n  }\n\n\n  /**\n   * @return {MmlNode} The internal Mathml structure.\n   */\n  public mml(): MmlNode {\n    if (!this.stack.Top().isKind('mml')) {\n      return null;\n    }\n    let node = this.stack.Top().First;\n    this.configuration.popParser();\n    return node;\n  }\n\n  /************************************************************************\n   *\n   *   String handling routines\n   */\n\n  /**\n   * Convert delimiter to character.\n   * @param {string} c The delimiter name.\n   * @return {string} The corresponding character.\n   */\n  public convertDelimiter(c: string): string {\n    const symbol = this.lookup('delimiter', c) as Symbol;\n    return symbol ? symbol.char : null;\n  }\n\n  /**\n   * @return {string}   Get the next unicode character in the string\n   */\n  public getCodePoint(): string {\n    const code = this.string.codePointAt(this.i);\n    return code === undefined ? '' : String.fromCodePoint(code);\n  }\n\n  /**\n   * @return {boolean} True if the next character to parse is a space.\n   */\n  public nextIsSpace(): boolean {\n    return !!this.string.charAt(this.i).match(/\\s/);\n  }\n\n  /**\n   * @return {string} Get the next non-space character.\n   */\n  public GetNext(): string {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n    return this.getCodePoint();\n  }\n\n  /**\n   * @return {string} Get and return a control-sequence name\n   */\n  public GetCS(): string {\n    let CS = this.string.slice(this.i).match(/^(([a-z]+) ?|[\\uD800-\\uDBFF].|.)/i);\n    if (CS) {\n      this.i += CS[0].length;\n      return CS[2] || CS[1];\n    } else {\n      this.i++;\n      return ' ';\n    }\n  }\n\n  /**\n   * Get and return a TeX argument (either a single character or control\n   *     sequence, or the contents of the next set of braces).\n   * @param {string} name Name of the current control sequence.\n   * @param {boolean} noneOK? True if no argument is OK.\n   * @return {string} The next argument.\n   */\n  public GetArgument(_name: string, noneOK?: boolean): string {\n    switch (this.GetNext()) {\n    case '':\n      if (!noneOK) {\n        // @test MissingArgFor\n        throw new TexError('MissingArgFor', 'Missing argument for %1', this.currentCS);\n      }\n      return null;\n    case '}':\n      if (!noneOK) {\n        // @test ExtraCloseMissingOpen\n        throw new TexError('ExtraCloseMissingOpen',\n                            'Extra close brace or missing open brace');\n      }\n      return null;\n    case '\\\\':\n      this.i++;\n      return '\\\\' + this.GetCS();\n    case '{':\n      let j = ++this.i, parens = 1;\n      while (this.i < this.string.length) {\n        switch (this.string.charAt(this.i++)) {\n        case '\\\\':  this.i++; break;\n        case '{':   parens++; break;\n        case '}':\n          if (--parens === 0) {\n            return this.string.slice(j, this.i - 1);\n          }\n          break;\n        }\n      }\n      // @test MissingCloseBrace\n      throw new TexError('MissingCloseBrace', 'Missing close brace');\n    }\n    const c = this.getCodePoint();\n    this.i += c.length;\n    return c;\n  }\n\n\n  /**\n   * Get an optional LaTeX argument in brackets.\n   * @param {string} name Name of the current control sequence.\n   * @param {string} def? The default value for the optional argument.\n   * @return {string} The optional argument.\n   */\n  public GetBrackets(_name: string, def?: string): string {\n    if (this.GetNext() !== '[') {\n      return def;\n    }\n    let j = ++this.i, parens = 0;\n    while (this.i < this.string.length) {\n      switch (this.string.charAt(this.i++)) {\n      case '{':   parens++; break;\n      case '\\\\':  this.i++; break;\n      case '}':\n        if (parens-- <= 0) {\n          // @test ExtraCloseLooking1\n          throw new TexError('ExtraCloseLooking',\n                              'Extra close brace while looking for %1', '\\']\\'');\n        }\n        break;\n      case ']':\n        if (parens === 0) {\n          return this.string.slice(j, this.i - 1);\n        }\n        break;\n      }\n    }\n    // @test MissingCloseBracket\n    throw new TexError('MissingCloseBracket',\n                        'Could not find closing \\']\\' for argument to %1', this.currentCS);\n  }\n\n  /**\n   *  Get the name of a delimiter (check it in the delimiter list).\n   * @param {string} name Name of the current control sequence.\n   * @param {boolean} braceOK? Are braces around the delimiter OK.\n   * @return {string} The delimiter name.\n   */\n  public GetDelimiter(name: string, braceOK?: boolean): string {\n    let c = this.GetNext(); this.i += c.length;\n    if (this.i <= this.string.length) {\n      if (c === '\\\\') {\n        c += this.GetCS();\n      } else if (c === '{' && braceOK) {\n        this.i--;\n        c = this.GetArgument(name).trim();\n      }\n      if (this.contains('delimiter', c)) {\n        return this.convertDelimiter(c);\n      }\n    }\n    // @test MissingOrUnrecognizedDelim1, MissingOrUnrecognizedDelim2\n    throw new TexError('MissingOrUnrecognizedDelim',\n                        'Missing or unrecognized delimiter for %1', this.currentCS);\n  }\n\n  /**\n   * Get a dimension (including its units).\n   * @param {string} name Name of the current control sequence.\n   * @return {string} The dimension string.\n   */\n  public GetDimen(name: string): string {\n    if (this.GetNext() === '{') {\n      let dimen = this.GetArgument(name);\n      let [value, unit] = ParseUtil.matchDimen(dimen);\n      if (value) {\n        // @test Raise In Line, Lower 2, (Raise|Lower) Negative\n        return value + unit;\n      }\n    } else {\n      // @test Above, Raise, Lower, Modulo, Above With Delims\n      let dimen = this.string.slice(this.i);\n      let [value, unit, length] = ParseUtil.matchDimen(dimen, true);\n      if (value) {\n        this.i += length;\n        return value + unit;\n      }\n    }\n    // @test MissingDimOrUnits\n    throw new TexError('MissingDimOrUnits',\n                        'Missing dimension or its units for %1', this.currentCS);\n  }\n\n  /**\n   *  Get everything up to the given control sequence (token)\n   * @param {string} name Name of the current control sequence.\n   * @param {string} token The element until where to parse.\n   * @return {string} The text between the current position and the given token.\n   */\n  public GetUpTo(_name: string, token: string): string {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n    let j = this.i;\n    let parens = 0;\n    while (this.i < this.string.length) {\n      let k = this.i;\n      let c = this.GetNext(); this.i += c.length;\n      switch (c) {\n      case '\\\\':  c += this.GetCS(); break;\n      case '{':   parens++; break;\n      case '}':\n        if (parens === 0) {\n          // @test ExtraCloseLooking2\n          throw new TexError('ExtraCloseLooking',\n                              'Extra close brace while looking for %1', token);\n        }\n        parens--;\n        break;\n      }\n      if (parens === 0 && c === token) {\n        return this.string.slice(j, k);\n      }\n    }\n    // @test TokenNotFoundForCommand\n    throw new TexError('TokenNotFoundForCommand',\n                        'Could not find %1 for %2', token, this.currentCS);\n  }\n\n  /**\n   * Parse the arguments of a control sequence in a new parser instance.\n   * @param {string} name Name of the current control sequence.\n   * @return {MmlNode} The parsed node.\n   */\n  public ParseArg(name: string): MmlNode  {\n    return new TexParser(this.GetArgument(name), this.stack.env,\n                         this.configuration).mml();\n  }\n\n  /**\n   * Parses a given string up to a given token in a new parser instance.\n   * @param {string} name Name of the current control sequence.\n   * @param {string} token A Token at which to end parsing.\n   * @return {MmlNode} The parsed node.\n   */\n  public ParseUpTo(name: string, token: string): MmlNode {\n    return new TexParser(this.GetUpTo(name, token), this.stack.env,\n                         this.configuration).mml();\n  }\n\n\n  /**\n   * Get a delimiter or empty argument\n   * @param {string} name Name of the current control sequence.\n   * @return {string} The delimiter.\n   */\n  public GetDelimiterArg(name: string): string {\n    let c = ParseUtil.trimSpaces(this.GetArgument(name));\n    if (c === '') {\n      return null;\n    }\n    if (this.contains('delimiter', c)) {\n      return c;\n    }\n    // @test MissingOrUnrecognizedDelim\n    throw new TexError('MissingOrUnrecognizedDelim',\n                        'Missing or unrecognized delimiter for %1', this.currentCS);\n  }\n\n  /**\n   * @return {boolean} True if a star follows the control sequence name.\n   */\n  public GetStar(): boolean {\n    let star = (this.GetNext() === '*');\n    if (star) {\n      this.i++;\n    }\n    return star;\n  }\n\n\n  /**\n   * Convenience method to create nodes with the node factory of the current\n   * configuration.\n   * @param {string} kind The kind of node to create.\n   * @param {any[]} ...rest The remaining arguments for the creation method.\n   * @return {MmlNode} The newly created node.\n   */\n  public create(kind: string, ...rest: any[]): MmlNode {\n    return this.configuration.nodeFactory.create(kind, ...rest);\n  }\n\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  The main MathJax global object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {VERSION} from './components/version.js';\nimport {HandlerList} from './core/HandlerList.js';\nimport {handleRetriesFor, retryAfter} from './util/Retries.js';\nimport {OptionList} from './util/Options.js';\nimport {MathDocument} from './core/MathDocument.js';\n\n/*****************************************************************/\n/**\n * The main MathJax global object\n */\nexport const mathjax = {\n  /**\n   *  The MathJax version number\n   */\n  version: VERSION,\n\n  /**\n   *  The list of registers document handlers\n   */\n  handlers: new HandlerList<any, any, any>(),\n\n  /**\n   * Creates a MathDocument using a registered handler that knows how to handl it\n   *\n   * @param {any} document        The document to handle\n   * @param {OptionList} options   The options to use for the document (e.g., input and output jax)\n   * @return {MathDocument}       The MathDocument to handle the document\n   */\n  document: function (document: any, options: OptionList): MathDocument<any, any, any> {\n    return mathjax.handlers.document(document, options);\n  },\n\n  /**\n   * The functions for handling retries if a file must be loaded dynamically\n   */\n  handleRetriesFor: handleRetriesFor,\n  retryAfter: retryAfter,\n\n  /**\n   * A function for loading external files (can be changed for node/browser use)\n   */\n  asyncLoad: null as ((file: string) => any),\n\n};\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements asynchronous loading of files\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {mathjax} from '../mathjax.js';\n\n/**\n * Load a file asynchronously using the mathjax.asynchLoad method, if there is one\n *\n * @param {string} name  The name of the file to load\n * @return {Promise}     The promise that is satisfied when the file is loaded\n */\nexport function asyncLoad(name: string): Promise<void> {\n  if (!mathjax.asyncLoad) {\n    return Promise.reject(`Can't load '${name}': No asyncLoad method specified`);\n  }\n  return new Promise((ok, fail) => {\n    const result = mathjax.asyncLoad(name);\n    if (result instanceof Promise) {\n      result.then((value: any) => ok(value)).catch((err: Error) => fail(err));\n    } else {\n      ok(result);\n    }\n  });\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Converts named entities to unicode characters\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {retryAfter} from './Retries.js';\nimport {asyncLoad} from './AsyncLoad.js';\nimport {OptionList} from './Options.js';\n\n/**\n * The type for lists of entities\n */\nexport type EntityList = {[name: string]: string};\n\n\n/**\n *  Options controlling the process of conversion\n */\nexport const options: OptionList = {\n  loadMissingEntities: true           // True means load entity files dynamically if needed\n};\n\n/**\n *  The entity name-to-value translation table\n *  (basic math entities -- others are loaded from external files)\n */\nexport const entities: EntityList = {\n  ApplyFunction: '\\u2061',\n  Backslash: '\\u2216',\n  Because: '\\u2235',\n  Breve: '\\u02D8',\n  Cap: '\\u22D2',\n  CenterDot: '\\u00B7',\n  CircleDot: '\\u2299',\n  CircleMinus: '\\u2296',\n  CirclePlus: '\\u2295',\n  CircleTimes: '\\u2297',\n  Congruent: '\\u2261',\n  ContourIntegral: '\\u222E',\n  Coproduct: '\\u2210',\n  Cross: '\\u2A2F',\n  Cup: '\\u22D3',\n  CupCap: '\\u224D',\n  Dagger: '\\u2021',\n  Del: '\\u2207',\n  Delta: '\\u0394',\n  Diamond: '\\u22C4',\n  DifferentialD: '\\u2146',\n  DotEqual: '\\u2250',\n  DoubleDot: '\\u00A8',\n  DoubleRightTee: '\\u22A8',\n  DoubleVerticalBar: '\\u2225',\n  DownArrow: '\\u2193',\n  DownLeftVector: '\\u21BD',\n  DownRightVector: '\\u21C1',\n  DownTee: '\\u22A4',\n  Downarrow: '\\u21D3',\n  Element: '\\u2208',\n  EqualTilde: '\\u2242',\n  Equilibrium: '\\u21CC',\n  Exists: '\\u2203',\n  ExponentialE: '\\u2147',\n  FilledVerySmallSquare: '\\u25AA',\n  ForAll: '\\u2200',\n  Gamma: '\\u0393',\n  Gg: '\\u22D9',\n  GreaterEqual: '\\u2265',\n  GreaterEqualLess: '\\u22DB',\n  GreaterFullEqual: '\\u2267',\n  GreaterLess: '\\u2277',\n  GreaterSlantEqual: '\\u2A7E',\n  GreaterTilde: '\\u2273',\n  Hacek: '\\u02C7',\n  Hat: '\\u005E',\n  HumpDownHump: '\\u224E',\n  HumpEqual: '\\u224F',\n  Im: '\\u2111',\n  ImaginaryI: '\\u2148',\n  Integral: '\\u222B',\n  Intersection: '\\u22C2',\n  InvisibleComma: '\\u2063',\n  InvisibleTimes: '\\u2062',\n  Lambda: '\\u039B',\n  Larr: '\\u219E',\n  LeftAngleBracket: '\\u27E8',\n  LeftArrow: '\\u2190',\n  LeftArrowRightArrow: '\\u21C6',\n  LeftCeiling: '\\u2308',\n  LeftDownVector: '\\u21C3',\n  LeftFloor: '\\u230A',\n  LeftRightArrow: '\\u2194',\n  LeftTee: '\\u22A3',\n  LeftTriangle: '\\u22B2',\n  LeftTriangleEqual: '\\u22B4',\n  LeftUpVector: '\\u21BF',\n  LeftVector: '\\u21BC',\n  Leftarrow: '\\u21D0',\n  Leftrightarrow: '\\u21D4',\n  LessEqualGreater: '\\u22DA',\n  LessFullEqual: '\\u2266',\n  LessGreater: '\\u2276',\n  LessSlantEqual: '\\u2A7D',\n  LessTilde: '\\u2272',\n  Ll: '\\u22D8',\n  Lleftarrow: '\\u21DA',\n  LongLeftArrow: '\\u27F5',\n  LongLeftRightArrow: '\\u27F7',\n  LongRightArrow: '\\u27F6',\n  Longleftarrow: '\\u27F8',\n  Longleftrightarrow: '\\u27FA',\n  Longrightarrow: '\\u27F9',\n  Lsh: '\\u21B0',\n  MinusPlus: '\\u2213',\n  NestedGreaterGreater: '\\u226B',\n  NestedLessLess: '\\u226A',\n  NotDoubleVerticalBar: '\\u2226',\n  NotElement: '\\u2209',\n  NotEqual: '\\u2260',\n  NotExists: '\\u2204',\n  NotGreater: '\\u226F',\n  NotGreaterEqual: '\\u2271',\n  NotLeftTriangle: '\\u22EA',\n  NotLeftTriangleEqual: '\\u22EC',\n  NotLess: '\\u226E',\n  NotLessEqual: '\\u2270',\n  NotPrecedes: '\\u2280',\n  NotPrecedesSlantEqual: '\\u22E0',\n  NotRightTriangle: '\\u22EB',\n  NotRightTriangleEqual: '\\u22ED',\n  NotSubsetEqual: '\\u2288',\n  NotSucceeds: '\\u2281',\n  NotSucceedsSlantEqual: '\\u22E1',\n  NotSupersetEqual: '\\u2289',\n  NotTilde: '\\u2241',\n  NotVerticalBar: '\\u2224',\n  Omega: '\\u03A9',\n  OverBar: '\\u203E',\n  OverBrace: '\\u23DE',\n  PartialD: '\\u2202',\n  Phi: '\\u03A6',\n  Pi: '\\u03A0',\n  PlusMinus: '\\u00B1',\n  Precedes: '\\u227A',\n  PrecedesEqual: '\\u2AAF',\n  PrecedesSlantEqual: '\\u227C',\n  PrecedesTilde: '\\u227E',\n  Product: '\\u220F',\n  Proportional: '\\u221D',\n  Psi: '\\u03A8',\n  Rarr: '\\u21A0',\n  Re: '\\u211C',\n  ReverseEquilibrium: '\\u21CB',\n  RightAngleBracket: '\\u27E9',\n  RightArrow: '\\u2192',\n  RightArrowLeftArrow: '\\u21C4',\n  RightCeiling: '\\u2309',\n  RightDownVector: '\\u21C2',\n  RightFloor: '\\u230B',\n  RightTee: '\\u22A2',\n  RightTeeArrow: '\\u21A6',\n  RightTriangle: '\\u22B3',\n  RightTriangleEqual: '\\u22B5',\n  RightUpVector: '\\u21BE',\n  RightVector: '\\u21C0',\n  Rightarrow: '\\u21D2',\n  Rrightarrow: '\\u21DB',\n  Rsh: '\\u21B1',\n  Sigma: '\\u03A3',\n  SmallCircle: '\\u2218',\n  Sqrt: '\\u221A',\n  Square: '\\u25A1',\n  SquareIntersection: '\\u2293',\n  SquareSubset: '\\u228F',\n  SquareSubsetEqual: '\\u2291',\n  SquareSuperset: '\\u2290',\n  SquareSupersetEqual: '\\u2292',\n  SquareUnion: '\\u2294',\n  Star: '\\u22C6',\n  Subset: '\\u22D0',\n  SubsetEqual: '\\u2286',\n  Succeeds: '\\u227B',\n  SucceedsEqual: '\\u2AB0',\n  SucceedsSlantEqual: '\\u227D',\n  SucceedsTilde: '\\u227F',\n  SuchThat: '\\u220B',\n  Sum: '\\u2211',\n  Superset: '\\u2283',\n  SupersetEqual: '\\u2287',\n  Supset: '\\u22D1',\n  Therefore: '\\u2234',\n  Theta: '\\u0398',\n  Tilde: '\\u223C',\n  TildeEqual: '\\u2243',\n  TildeFullEqual: '\\u2245',\n  TildeTilde: '\\u2248',\n  UnderBar: '\\u005F',\n  UnderBrace: '\\u23DF',\n  Union: '\\u22C3',\n  UnionPlus: '\\u228E',\n  UpArrow: '\\u2191',\n  UpDownArrow: '\\u2195',\n  UpTee: '\\u22A5',\n  Uparrow: '\\u21D1',\n  Updownarrow: '\\u21D5',\n  Upsilon: '\\u03A5',\n  Vdash: '\\u22A9',\n  Vee: '\\u22C1',\n  VerticalBar: '\\u2223',\n  VerticalTilde: '\\u2240',\n  Vvdash: '\\u22AA',\n  Wedge: '\\u22C0',\n  Xi: '\\u039E',\n  amp: '\\u0026',\n  acute: '\\u00B4',\n  aleph: '\\u2135',\n  alpha: '\\u03B1',\n  amalg: '\\u2A3F',\n  and: '\\u2227',\n  ang: '\\u2220',\n  angmsd: '\\u2221',\n  angsph: '\\u2222',\n  ape: '\\u224A',\n  backprime: '\\u2035',\n  backsim: '\\u223D',\n  backsimeq: '\\u22CD',\n  beta: '\\u03B2',\n  beth: '\\u2136',\n  between: '\\u226C',\n  bigcirc: '\\u25EF',\n  bigodot: '\\u2A00',\n  bigoplus: '\\u2A01',\n  bigotimes: '\\u2A02',\n  bigsqcup: '\\u2A06',\n  bigstar: '\\u2605',\n  bigtriangledown: '\\u25BD',\n  bigtriangleup: '\\u25B3',\n  biguplus: '\\u2A04',\n  blacklozenge: '\\u29EB',\n  blacktriangle: '\\u25B4',\n  blacktriangledown: '\\u25BE',\n  blacktriangleleft: '\\u25C2',\n  bowtie: '\\u22C8',\n  boxdl: '\\u2510',\n  boxdr: '\\u250C',\n  boxminus: '\\u229F',\n  boxplus: '\\u229E',\n  boxtimes: '\\u22A0',\n  boxul: '\\u2518',\n  boxur: '\\u2514',\n  bsol: '\\u005C',\n  bull: '\\u2022',\n  cap: '\\u2229',\n  check: '\\u2713',\n  chi: '\\u03C7',\n  circ: '\\u02C6',\n  circeq: '\\u2257',\n  circlearrowleft: '\\u21BA',\n  circlearrowright: '\\u21BB',\n  circledR: '\\u00AE',\n  circledS: '\\u24C8',\n  circledast: '\\u229B',\n  circledcirc: '\\u229A',\n  circleddash: '\\u229D',\n  clubs: '\\u2663',\n  colon: '\\u003A',\n  comp: '\\u2201',\n  ctdot: '\\u22EF',\n  cuepr: '\\u22DE',\n  cuesc: '\\u22DF',\n  cularr: '\\u21B6',\n  cup: '\\u222A',\n  curarr: '\\u21B7',\n  curlyvee: '\\u22CE',\n  curlywedge: '\\u22CF',\n  dagger: '\\u2020',\n  daleth: '\\u2138',\n  ddarr: '\\u21CA',\n  deg: '\\u00B0',\n  delta: '\\u03B4',\n  digamma: '\\u03DD',\n  div: '\\u00F7',\n  divideontimes: '\\u22C7',\n  dot: '\\u02D9',\n  doteqdot: '\\u2251',\n  dotplus: '\\u2214',\n  dotsquare: '\\u22A1',\n  dtdot: '\\u22F1',\n  ecir: '\\u2256',\n  efDot: '\\u2252',\n  egs: '\\u2A96',\n  ell: '\\u2113',\n  els: '\\u2A95',\n  empty: '\\u2205',\n  epsi: '\\u03B5',\n  epsiv: '\\u03F5',\n  erDot: '\\u2253',\n  eta: '\\u03B7',\n  eth: '\\u00F0',\n  flat: '\\u266D',\n  fork: '\\u22D4',\n  frown: '\\u2322',\n  gEl: '\\u2A8C',\n  gamma: '\\u03B3',\n  gap: '\\u2A86',\n  gimel: '\\u2137',\n  gnE: '\\u2269',\n  gnap: '\\u2A8A',\n  gne: '\\u2A88',\n  gnsim: '\\u22E7',\n  gt: '\\u003E',\n  gtdot: '\\u22D7',\n  harrw: '\\u21AD',\n  hbar: '\\u210F',\n  hellip: '\\u2026',\n  hookleftarrow: '\\u21A9',\n  hookrightarrow: '\\u21AA',\n  imath: '\\u0131',\n  infin: '\\u221E',\n  intcal: '\\u22BA',\n  iota: '\\u03B9',\n  jmath: '\\u0237',\n  kappa: '\\u03BA',\n  kappav: '\\u03F0',\n  lEg: '\\u2A8B',\n  lambda: '\\u03BB',\n  lap: '\\u2A85',\n  larrlp: '\\u21AB',\n  larrtl: '\\u21A2',\n  lbrace: '\\u007B',\n  lbrack: '\\u005B',\n  le: '\\u2264',\n  leftleftarrows: '\\u21C7',\n  leftthreetimes: '\\u22CB',\n  lessdot: '\\u22D6',\n  lmoust: '\\u23B0',\n  lnE: '\\u2268',\n  lnap: '\\u2A89',\n  lne: '\\u2A87',\n  lnsim: '\\u22E6',\n  longmapsto: '\\u27FC',\n  looparrowright: '\\u21AC',\n  lowast: '\\u2217',\n  loz: '\\u25CA',\n  lt: '\\u003C',\n  ltimes: '\\u22C9',\n  ltri: '\\u25C3',\n  macr: '\\u00AF',\n  malt: '\\u2720',\n  mho: '\\u2127',\n  mu: '\\u03BC',\n  multimap: '\\u22B8',\n  nLeftarrow: '\\u21CD',\n  nLeftrightarrow: '\\u21CE',\n  nRightarrow: '\\u21CF',\n  nVDash: '\\u22AF',\n  nVdash: '\\u22AE',\n  natur: '\\u266E',\n  nearr: '\\u2197',\n  nharr: '\\u21AE',\n  nlarr: '\\u219A',\n  not: '\\u00AC',\n  nrarr: '\\u219B',\n  nu: '\\u03BD',\n  nvDash: '\\u22AD',\n  nvdash: '\\u22AC',\n  nwarr: '\\u2196',\n  omega: '\\u03C9',\n  omicron: '\\u03BF',\n  or: '\\u2228',\n  osol: '\\u2298',\n  period: '\\u002E',\n  phi: '\\u03C6',\n  phiv: '\\u03D5',\n  pi: '\\u03C0',\n  piv: '\\u03D6',\n  prap: '\\u2AB7',\n  precnapprox: '\\u2AB9',\n  precneqq: '\\u2AB5',\n  precnsim: '\\u22E8',\n  prime: '\\u2032',\n  psi: '\\u03C8',\n  quot: '\\u0022',\n  rarrtl: '\\u21A3',\n  rbrace: '\\u007D',\n  rbrack: '\\u005D',\n  rho: '\\u03C1',\n  rhov: '\\u03F1',\n  rightrightarrows: '\\u21C9',\n  rightthreetimes: '\\u22CC',\n  ring: '\\u02DA',\n  rmoust: '\\u23B1',\n  rtimes: '\\u22CA',\n  rtri: '\\u25B9',\n  scap: '\\u2AB8',\n  scnE: '\\u2AB6',\n  scnap: '\\u2ABA',\n  scnsim: '\\u22E9',\n  sdot: '\\u22C5',\n  searr: '\\u2198',\n  sect: '\\u00A7',\n  sharp: '\\u266F',\n  sigma: '\\u03C3',\n  sigmav: '\\u03C2',\n  simne: '\\u2246',\n  smile: '\\u2323',\n  spades: '\\u2660',\n  sub: '\\u2282',\n  subE: '\\u2AC5',\n  subnE: '\\u2ACB',\n  subne: '\\u228A',\n  supE: '\\u2AC6',\n  supnE: '\\u2ACC',\n  supne: '\\u228B',\n  swarr: '\\u2199',\n  tau: '\\u03C4',\n  theta: '\\u03B8',\n  thetav: '\\u03D1',\n  tilde: '\\u02DC',\n  times: '\\u00D7',\n  triangle: '\\u25B5',\n  triangleq: '\\u225C',\n  upsi: '\\u03C5',\n  upuparrows: '\\u21C8',\n  veebar: '\\u22BB',\n  vellip: '\\u22EE',\n  weierp: '\\u2118',\n  xi: '\\u03BE',\n  yen: '\\u00A5',\n  zeta: '\\u03B6',\n  zigrarr: '\\u21DD',\n\n  //\n  //  Needed by TeX input jax\n  nbsp: '\\u00A0',\n  rsquo: '\\u2019',\n  lsquo: '\\u2018'\n};\n\n/**\n * The files that have been loaded\n */\nconst loaded: {[name: string]: boolean} = {};\n\n/**\n * Used by entity files to add more entities to the table\n *\n * @param {EntityList} additions The entities to add\n * @param {string} file          The name of the file that they came from\n */\nexport function add(additions: EntityList, file: string) {\n  Object.assign(entities, additions);\n  loaded[file] = true;\n}\n\n/**\n * Used to remove an entity from the list, if needed\n *\n * @param {string} entity  The name of the entity to remove\n */\nexport function remove(entity: string) {\n  delete entities[entity];\n}\n\n/**\n * @param {string} text  The text whose entities are to be replaced\n * @return {string}      The text with entries replaced\n */\nexport function translate(text: string): string {\n  return text.replace(/&([a-z][a-z0-9]*|#(?:[0-9]+|x[0-9a-f]+));/ig, replace);\n}\n\n/**\n * Returns the unicode character for an entity, if found\n * If not, loads an entity file to see if it is there (and retries after loading)\n * Otherwire, returns the original entity string\n *\n * @param {string} match   The complete entity being replaced\n * @param {string} entity  The name of the entity to be replaced\n * @return {string}        The unicode character for the entity, or the entity name (if none found)\n */\nfunction replace(match: string, entity: string): string {\n  if (entity.charAt(0) === '#') {\n    return numeric(entity.slice(1));\n  }\n  if (entities[entity]) {\n    return entities[entity];\n  }\n  if (options['loadMissingEntities']) {\n    let file = (entity.match(/^[a-zA-Z](fr|scr|opf)$/) ? RegExp.$1 : entity.charAt(0).toLowerCase());\n    if (!loaded[file]) {\n      loaded[file] = true;\n      retryAfter(asyncLoad('./util/entities/' + file + '.js'));\n    }\n  }\n  return match;\n}\n\n/**\n * @param {string} entity  The character code point as a string\n * @return {string}        The character(s) with the given code point\n */\nexport function numeric(entity: string): string {\n  let n = (entity.charAt(0) === 'x' ?\n           parseInt(entity.slice(1), 16) :\n           parseInt(entity));\n  return String.fromCodePoint(n);\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implement FunctionList object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {PrioritizedList, PrioritizedListItem} from './PrioritizedList.js';\n\n/*****************************************************************/\n/**\n *  The FunctionListItem interface (extends PrioritizedListItem<Function>)\n */\n\nexport interface FunctionListItem extends PrioritizedListItem<Function> {}\n\n/*****************************************************************/\n/**\n *  Implements the FunctionList class (extends PrioritizedList<Function>)\n */\n\nexport class FunctionList extends PrioritizedList<Function> {\n\n  /**\n   * Executes the functions in the list (in prioritized order),\n   *   passing the given data to the functions.  If any return\n   *   false, the list is terminated.\n   *\n   * @param {any[]} data  The array of arguments to pass to the functions\n   * @return {boolean}    False if any function stopped the list by\n   *                       returning false, true otherwise\n   */\n  public execute(...data: any[]): boolean {\n    for (const item of this) {\n      let result = item.item(...data);\n      if (result === false) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Executes the functions in the list (in prioritized order) asynchronously,\n   *   passing the given data to the functions, and doing the next function\n   *   only when the previous one completes.  If the function returns a\n   *   Promise, then use that to control the flow.  Otherwise, if the\n   *   function returns false, the list is terminated.\n   * This function returns a Promise.  If any function in the list fails,\n   *   the promise fails.  If any function returns false, the promise\n   *   succeeds, but passes false as its argument.  Otherwise it succeeds\n   *   and passes true.\n   *\n   * @param {any[]} data  The array of arguments to pass to the functions\n   * @return {Promise}    The promise that is satisfied when the function\n   *                       list completes (with argument true or false\n   *                       depending on whether some function returned\n   *                       false or not).\n   */\n  public asyncExecute(...data: any[]): Promise<void> {\n    let i = -1;\n    let items = this.items;\n    return new Promise((ok: Function, fail: Function) => {\n      (function execute() {\n        while (++i < items.length) {\n          let result = items[i].item(...data);\n          if (result instanceof Promise) {\n            result.then(execute).catch(err => fail(err));\n            return;\n          }\n          if (result === false) {\n            ok(false);\n            return;\n          }\n        }\n        ok(true);\n      })();\n    });\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements a list sorted by a numeric priority\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\n/*****************************************************************/\n/**\n *  The PrioritizedListItem<DataClass> interface\n *\n * @template DataClass   The class of data stored in the item\n */\n\nexport interface PrioritizedListItem<DataClass> {\n\n  /**\n   * The priority of this item\n   */\n  priority: number;\n\n  /**\n   * The data for the list item\n   */\n  item: DataClass;\n}\n\n/*****************************************************************/\n/**\n *  Implements the PrioritizedList<DataClass> class\n *\n * @template DataClass   The class of data stored in the list\n */\n\nexport class PrioritizedList<DataClass> {\n\n  /**\n   * The default priority for items added to the list\n   */\n  public static DEFAULTPRIORITY: number = 5;\n\n  /**\n   * The list of items, sorted by priority (smallest number first)\n   */\n  protected items: PrioritizedListItem<DataClass>[] = [];\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    this.items = [];\n  }\n\n  /**\n   * Make the list iterable, and return the data for the items in the list\n   *\n   * @return {{next: Function}}  The object containing the iterator's next() function\n   */\n  public [Symbol.iterator](): Iterator<PrioritizedListItem<DataClass>> {\n    let i = 0;\n    let items = this.items;\n    return {\n      /* tslint:disable-next-line:jsdoc-require */\n      next(): IteratorResult<PrioritizedListItem<DataClass>> {\n        return {value: items[i++], done: (i > items.length)};\n      }\n    };\n  }\n\n  /**\n   * Add an item to the list\n   *\n   * @param {DataClass} item   The data for the item to be added\n   * @param {number} priority  The priority for the item\n   * @return {DataClass}       The data itself\n   */\n  public add(item: DataClass, priority: number = PrioritizedList.DEFAULTPRIORITY): DataClass {\n    let i = this.items.length;\n    do {\n      i--;\n    } while (i >= 0 && priority < this.items[i].priority);\n    this.items.splice(i + 1, 0, {item: item, priority: priority});\n    return item;\n  }\n\n  /**\n   * Remove an item from the list\n   *\n   * @param {DataClass} item   The data for the item to be removed\n   */\n  public remove(item: DataClass) {\n    let i = this.items.length;\n    do {\n      i--;\n    } while (i >= 0 && this.items[i].item !== item);\n    if (i >= 0) {\n      this.items.splice(i, 1);\n    }\n  }\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements methods for handling asynchronous actions\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\n\n/*****************************************************************/\n/*\n *  The legacy MathJax object  (FIXME: remove this after all v2 code is gone)\n */\n\ndeclare var MathJax: {Callback: {After: Function}};\n\n\n/*****************************************************************/\n/**\n *  Allow us to pass a promise as part of an Error object\n */\n\nexport interface RetryError extends Error {\n  retry: Promise<any>;\n}\n\n/*****************************************************************/\n/**\n * A wrapper for actions that may be asynchronous.  This will\n *   rerun the action after the asychronous action completes.\n *   Usually, this is for dynamic loading of files.  Legacy\n *   MathJax does that a lot, so we still need it for now, but\n *   may be able to go without it in the future.\n *\n *   Example:\n *\n *     HandleRetriesFor(() => {\n *\n *         html.findMath()\n *             .compile()\n *             .getMetrics()\n *             .typeset()\n *             .updateDocument();\n *\n *     }).catch(err => {\n *       console.log(err.message);\n *     });\n *\n * @param {Function} code  The code to run that might cause retries\n * @return {Promise}       A promise that is satisfied when the code\n *                         runs completely, and fails if the code\n *                         generates an error (that is not a retry).\n */\n\nexport function handleRetriesFor(code: Function): Promise<any> {\n  return new Promise(function run(ok: Function, fail: Function) {\n    try {\n      ok(code());\n    } catch (err) {\n      if (err.retry && err.retry instanceof Promise) {\n        err.retry.then(() => run(ok, fail))\n                 .catch((perr: Error) => fail(perr));\n      } else if (err.restart && err.restart.isCallback) {\n        // FIXME: Remove this branch when all legacy code is gone\n        MathJax.Callback.After(() => run(ok, fail), err.restart);\n      } else {\n        fail(err);\n      }\n    }\n  });\n}\n\n/*****************************************************************/\n/**\n * Tells HandleRetriesFor() to wait for this promise to be fulfilled\n *   before rerunning the code.  Causes an error to be thrown, so\n *   calling this terminates the code at that point.\n *\n * @param {Promise} promise  The promise that must be satisfied before\n *                            actions will continue\n */\n\nexport function retryAfter(promise: Promise<any>) {\n  let err = new Error('MathJax retry') as RetryError;\n  err.retry = promise;\n  throw err;\n}\n"],"names":["VERSION","register","handler","this","add","priority","unregister","remove","handlesDocument","document","item","Error","options","create","PrioritizedList","HandlerList","ConfigurationHandler","name","fallback","items","tags","nodes","preprocessors","postprocessors","initMethod","configMethod","parser","Object","assign","character","delimiter","macro","environment","makeProcessor","func","Array","isArray","_create","config","DEFAULTPRIORITY","init","conf","map","pre","post","Configuration","configuration","set","local","maps","Map","get","keys","packages","parsers","FunctionList","configurations","handlers","SubHandlers","slice","reverse","pkg","addPackage","append","execute","jax","addFilters","getPackage","parseOptions","nodeFactory","setCreators","kind","itemFactory","setNodeClass","TagsFactory","addTags","defaultOptions","userOptions","indexOf","preFilters","postFilters","ParserConfiguration","MapHandler","getMap","_configuration","_fallback","warn","parse","input","result","env","symbol","from","lookup","applicable","contains","toString","names","push","join","retrieve","message","console","log","SubHandler","fallbacks","subHandler","values","NodeUtil","attrs","setProperties","node","properties","value","texClass","setProperty","isKind","attributes","has","setChild","position","child","childNodes","parent","isType","createEntity","code","String","fromCodePoint","parseInt","getChildren","getText","appendChildren","children","appendChild","setAttribute","attribute","property","getProperty","getAttribute","attr","removeProperties","removeProperty","getChildAt","copyChildren","oldNode","newNode","i","length","copyAttributes","getAllProperties","isEmbellished","getTexClass","getCoreMO","coreMO","isNode","AbstractMmlNode","AbstractMmlEmptyNode","isInferred","getForm","mo","forms","getForms","form","MmlMo","OPTABLE","ParseUtil","emPerInch","UNIT_CASES","m","num","unit","dimenEnd","RegExp","dimenRest","matchDimen","dim","rest","match","Em","parseFloat","muReplace","replace","Math","abs","toFixed","mathPalette","fence","side","D","T","mml","internalText","text","def","entities","nbsp","textNode","addArgs","s1","s2","removeBraces","count","trim","readValue","end","braces","index","start","startCount","stopCount","c","dimen2em","cols","W","n","fenced","open","close","big","color","nf","mrow","TEXCLASS","INNER","stack","openNode","stretchy","symmetric","OPEN","closeNode","CLOSE","fixedFence","ORD","fixInitialMO","REL","mi","unshift","internalMath","level","font","mathvariant","k","charAt","atom","substr","len","displaystyle","scriptlevel","underOver","base","script","pos","checkMovableLimits","lspace","rspace","over","under","OP","movesupsub","movablelimits","trimSpaces","TEXT","setArrayAlign","array","align","arraydef","substituteArgs","args","str","newstring","checkMaxMacros","isMacro","macroCount","checkEqnEnv","global","eqnenv","copyNode","tree","copy","walkTree","addNode","lists","split","list","MmlFilterAttribute","_parser","_name","getFontDef","keyvalOptions","attrib","allowed","error","key","val","JSON","readKeyval","hasOwnProperty","_factory","_env","inner","isInner","Push","Top","checkItem","Pop","copyEnv","pop","isOpen","Prev","noPop","top","First","_symbol","_char","_attributes","Symbol","_func","_args","Macro","parseResult","parserFor","mapped","AbstractSymbolMap","_regExp","test","RegExpMap","object","delete","AbstractParseMap","json","char","CharacterMap","DelimiterMap","functionMap","MacroMap","saveCommand","currentCS","CommandMap","envParser","EnvironmentMap","tag","id","Label","taggable","defaultTags","tagId","tagFormat","noTag","labelId","TagInfo","counter","allCounter","ids","allIds","labels","allLabels","redo","refUpdate","currentTag","history","enTag","cell","row","minlabelspacing","noFormat","formatTag","notag","label","formatUrl","encodeURIComponent","formatId","formatNumber","autoTag","clearTag","getTag","force","makeTag","ct","resetTag","reset","offset","startEquation","math","undefined","recompile","inputData","finishEquation","state","finalize","display","makeId","AbstractTags","NoTags","tagsMapping","find","x","AllTags","OPTIONS","tagSide","tagIndent","useLabelIds","ignoreDuplicateLabels","constr","setDefault","getDefault","TexError","processString","parts","pattern","_string","ENV","pushParser","Parse","string","getCodePoint","arg","PushAll","popParser","convertDelimiter","codePointAt","nextIsSpace","GetNext","GetCS","CS","GetArgument","noneOK","j","parens","GetBrackets","GetDelimiter","braceOK","GetDimen","dimen","GetUpTo","token","ParseArg","TexParser","ParseUpTo","GetDelimiterArg","GetStar","star","mathjax","version","handleRetriesFor","retryAfter","asyncLoad","Promise","ok","fail","then","catch","err","reject","loadMissingEntities","ApplyFunction","Backslash","Because","Breve","Cap","CenterDot","CircleDot","CircleMinus","CirclePlus","CircleTimes","Congruent","ContourIntegral","Coproduct","Cross","Cup","CupCap","Dagger","Del","Delta","Diamond","DifferentialD","DotEqual","DoubleDot","DoubleRightTee","DoubleVerticalBar","DownArrow","DownLeftVector","DownRightVector","DownTee","Downarrow","Element","EqualTilde","Equilibrium","Exists","ExponentialE","FilledVerySmallSquare","ForAll","Gamma","Gg","GreaterEqual","GreaterEqualLess","GreaterFullEqual","GreaterLess","GreaterSlantEqual","GreaterTilde","Hacek","Hat","HumpDownHump","HumpEqual","Im","ImaginaryI","Integral","Intersection","InvisibleComma","InvisibleTimes","Lambda","Larr","LeftAngleBracket","LeftArrow","LeftArrowRightArrow","LeftCeiling","LeftDownVector","LeftFloor","LeftRightArrow","LeftTee","LeftTriangle","LeftTriangleEqual","LeftUpVector","LeftVector","Leftarrow","Leftrightarrow","LessEqualGreater","LessFullEqual","LessGreater","LessSlantEqual","LessTilde","Ll","Lleftarrow","LongLeftArrow","LongLeftRightArrow","LongRightArrow","Longleftarrow","Longleftrightarrow","Longrightarrow","Lsh","MinusPlus","NestedGreaterGreater","NestedLessLess","NotDoubleVerticalBar","NotElement","NotEqual","NotExists","NotGreater","NotGreaterEqual","NotLeftTriangle","NotLeftTriangleEqual","NotLess","NotLessEqual","NotPrecedes","NotPrecedesSlantEqual","NotRightTriangle","NotRightTriangleEqual","NotSubsetEqual","NotSucceeds","NotSucceedsSlantEqual","NotSupersetEqual","NotTilde","NotVerticalBar","Omega","OverBar","OverBrace","PartialD","Phi","Pi","PlusMinus","Precedes","PrecedesEqual","PrecedesSlantEqual","PrecedesTilde","Product","Proportional","Psi","Rarr","Re","ReverseEquilibrium","RightAngleBracket","RightArrow","RightArrowLeftArrow","RightCeiling","RightDownVector","RightFloor","RightTee","RightTeeArrow","RightTriangle","RightTriangleEqual","RightUpVector","RightVector","Rightarrow","Rrightarrow","Rsh","Sigma","SmallCircle","Sqrt","Square","SquareIntersection","SquareSubset","SquareSubsetEqual","SquareSuperset","SquareSupersetEqual","SquareUnion","Star","Subset","SubsetEqual","Succeeds","SucceedsEqual","SucceedsSlantEqual","SucceedsTilde","SuchThat","Sum","Superset","SupersetEqual","Supset","Therefore","Theta","Tilde","TildeEqual","TildeFullEqual","TildeTilde","UnderBar","UnderBrace","Union","UnionPlus","UpArrow","UpDownArrow","UpTee","Uparrow","Updownarrow","Upsilon","Vdash","Vee","VerticalBar","VerticalTilde","Vvdash","Wedge","Xi","amp","acute","aleph","alpha","amalg","and","ang","angmsd","angsph","ape","backprime","backsim","backsimeq","beta","beth","between","bigcirc","bigodot","bigoplus","bigotimes","bigsqcup","bigstar","bigtriangledown","bigtriangleup","biguplus","blacklozenge","blacktriangle","blacktriangledown","blacktriangleleft","bowtie","boxdl","boxdr","boxminus","boxplus","boxtimes","boxul","boxur","bsol","bull","cap","check","chi","circ","circeq","circlearrowleft","circlearrowright","circledR","circledS","circledast","circledcirc","circleddash","clubs","colon","comp","ctdot","cuepr","cuesc","cularr","cup","curarr","curlyvee","curlywedge","dagger","daleth","ddarr","deg","delta","digamma","div","divideontimes","dot","doteqdot","dotplus","dotsquare","dtdot","ecir","efDot","egs","ell","els","empty","epsi","epsiv","erDot","eta","eth","flat","fork","frown","gEl","gamma","gap","gimel","gnE","gnap","gne","gnsim","gt","gtdot","harrw","hbar","hellip","hookleftarrow","hookrightarrow","imath","infin","intcal","iota","jmath","kappa","kappav","lEg","lambda","lap","larrlp","larrtl","lbrace","lbrack","le","leftleftarrows","leftthreetimes","lessdot","lmoust","lnE","lnap","lne","lnsim","longmapsto","looparrowright","lowast","loz","lt","ltimes","ltri","macr","malt","mho","mu","multimap","nLeftarrow","nLeftrightarrow","nRightarrow","nVDash","nVdash","natur","nearr","nharr","nlarr","not","nrarr","nu","nvDash","nvdash","nwarr","omega","omicron","or","osol","period","phi","phiv","pi","piv","prap","precnapprox","precneqq","precnsim","prime","psi","quot","rarrtl","rbrace","rbrack","rho","rhov","rightrightarrows","rightthreetimes","ring","rmoust","rtimes","rtri","scap","scnE","scnap","scnsim","sdot","searr","sect","sharp","sigma","sigmav","simne","smile","spades","sub","subE","subnE","subne","supE","supnE","supne","swarr","tau","theta","thetav","tilde","times","triangle","triangleq","upsi","upuparrows","veebar","vellip","weierp","xi","yen","zeta","zigrarr","rsquo","lsquo","loaded","entity","numeric","file","$1","toLowerCase","additions","data","asyncExecute","iterator","next","done","splice","run","retry","perr","restart","isCallback","MathJax","Callback","After","promise"],"sourceRoot":""}