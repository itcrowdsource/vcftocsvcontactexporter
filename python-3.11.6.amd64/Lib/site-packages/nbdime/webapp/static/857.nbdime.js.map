{"version":3,"file":"857.nbdime.js","mappings":"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","sources":["webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/core/FindMath.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/core/InputJax.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/core/MathItem.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/FilterUtil.ts","webpack://nbdime-webapp/../../node_modules/mathjax-full/ts/input/tex/FindTeX.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Interfaces and abstract classes for FindMath objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {userOptions, defaultOptions, OptionList} from '../util/Options.js';\nimport {ProtoItem} from './MathItem.js';\n\n/*****************************************************************/\n/**\n *  The FindMath interface\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template _D  The Document class\n */\nexport interface FindMath<N, T, _D> {\n  /**\n   * One of two possibilities:  Look through a DOM element,\n   *   or look through an array of strings for delimited math.\n   *\n   * @param {N} node   The node to search for math\n   * @return {ProtoItem<N, T>[]}\n   */\n  findMath(node: N): ProtoItem<N, T>[];\n  /**\n   *\n   * @param {string[]} strings    The strings to search for math\n   * @return {ProtoItem<N, T>[]}\n   */\n  findMath(strings: string[]): ProtoItem<N, T>[];\n}\n\n/*****************************************************************/\n/**\n *  The FindMath abstract class\n */\n\n/**\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport abstract class AbstractFindMath<N, T, D> implements FindMath<N, T, D> {\n\n  /**\n   * The default options for FindMath\n   */\n  public static OPTIONS: OptionList = {};\n\n  /**\n   * The actual options for this instance\n   */\n  protected options: OptionList;\n\n  /**\n   * @param {OptionList} options  The user options for this instance\n   */\n  constructor(options: OptionList) {\n    let CLASS = this.constructor as typeof AbstractFindMath;\n    this.options = userOptions(defaultOptions({}, CLASS.OPTIONS), options);\n  }\n\n  /**\n   * Locate math in an Element or a string array;\n   *\n   * @param {Element | string[]} where  The node or string array to search for math\n   * @return {ProtoItem[]}              The array of proto math items found\n   */\n  public abstract findMath(where: N | string[]): ProtoItem<N, T>[];\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the interface and abstract class for the InputJax\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {MathDocument} from './MathDocument.js';\nimport {MathItem, ProtoItem} from './MathItem.js';\nimport {MmlNode} from './MmlTree/MmlNode.js';\nimport {MmlFactory} from './MmlTree/MmlFactory.js';\nimport {userOptions, defaultOptions, OptionList} from '../util/Options.js';\nimport {FunctionList} from '../util/FunctionList.js';\nimport {DOMAdaptor} from '../core/DOMAdaptor.js';\n\n/*****************************************************************/\n/**\n *  The InputJax interface\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport interface InputJax<N, T, D> {\n  /**\n   * The name of the input jax subclass (e.g,. 'TeX')\n   */\n  name: string;\n\n  /**\n   * Whether this input jax processes string arrays or DOM nodes\n   * (TeX and AsciiMath process strings, MathML processes DOM nodes)\n   */\n  processStrings: boolean;\n\n  /**\n   * The options for this input jax instance\n   */\n  options: OptionList;\n\n  /**\n   * Lists of pre- and post-filters to call before and after processing the input\n   */\n  preFilters: FunctionList;\n  postFilters: FunctionList;\n\n  /**\n   * The DOM adaptor for managing HTML elements\n   */\n  adaptor: DOMAdaptor<N, T, D>;\n\n  /**\n   * The MmlFactory for this input jax\n   */\n  mmlFactory: MmlFactory;\n\n  /**\n   * @param {DOMAdaptor} adaptor The adaptor to use in this jax\n   */\n  setAdaptor(adaptor: DOMAdaptor<N, T, D>): void;\n\n  /**\n   * @param {MmlFactory} mmlFactory The MmlFactory to use in this jax\n   */\n  setMmlFactory(mmlFactory: MmlFactory): void;\n\n  /**\n   * Do any initialization that depends on the document being set up\n   */\n  initialize(): void;\n\n  /**\n   * Reset any needed features of the input jax\n   *\n   * @param {any[]} args   The arguments needed by the reset operation\n   */\n  reset(...args: any[]): void;\n\n  /**\n   * Finds the math within the DOM or the list of strings\n   *\n   * @param {N | string[]} which   The element or array of strings to be searched for math\n   * @param {OptionList} options   The options for the search, if any\n   * @return {ProtoItem[]}         Array of proto math items found (further processed by the\n   *                                handler to produce actual MathItem objects)\n   */\n  findMath(which: N | string[], options?: OptionList): ProtoItem<N, T>[];\n\n  /**\n   * Convert the math in a math item into the internal format\n   *\n   * @param {MathItem} math  The MathItem whose math content is to processed\n   * @param {MathDocument} document The MathDocument for this input jax.\n   * @return {MmlNode}       The resulting internal node tree for the math\n   */\n  compile(math: MathItem<N, T, D>, document: MathDocument<N, T, D>): MmlNode;\n}\n\n/*****************************************************************/\n/**\n *  The abstract InputJax class\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport abstract class AbstractInputJax<N, T, D> implements InputJax<N, T, D> {\n\n  /**\n   * The name of the input jax\n   */\n  public static NAME: string = 'generic';\n\n  /**\n   * The default options for the input jax\n   */\n  public static OPTIONS: OptionList = {};\n\n  /**\n   * The actual options supplied to the input jax\n   */\n  public options: OptionList;\n\n  /**\n   * Filters to run on the TeX string before it is processed\n   */\n  public preFilters: FunctionList;\n\n  /**\n   * Filters to run on the generated MathML after the TeX string is processed\n   */\n  public postFilters: FunctionList;\n\n  /**\n   * The DOMAdaptor for the MathDocument for this input jax\n   */\n  public adaptor: DOMAdaptor<N, T, D> = null;  // set by the handler\n  /**\n   * The MathML node factory\n   */\n  public mmlFactory: MmlFactory = null;        // set by the handler\n\n  /**\n   * @param {OptionList} options  The options to apply to this input jax\n   *\n   * @constructor\n   */\n  constructor(options: OptionList = {}) {\n    let CLASS = this.constructor as typeof AbstractInputJax;\n    this.options = userOptions(defaultOptions({}, CLASS.OPTIONS), options);\n    this.preFilters = new FunctionList();\n    this.postFilters = new FunctionList();\n  }\n\n  /**\n   * @return {string}  The name of this input jax class\n   */\n  public get name(): string {\n    return (this.constructor as typeof AbstractInputJax).NAME;\n  }\n\n  /**\n   * @override\n   */\n  public setAdaptor(adaptor: DOMAdaptor<N, T, D>) {\n    this.adaptor = adaptor;\n  }\n\n  /**\n   * @override\n   */\n  public setMmlFactory(mmlFactory: MmlFactory) {\n    this.mmlFactory = mmlFactory;\n  }\n\n  /**\n   * @override\n   */\n  public initialize() {\n  }\n\n  /**\n   * @override\n   */\n  public reset(..._args: any[]) {\n  }\n\n  /**\n   * @return {boolean}  True means find math in string array, false means in DOM element\n   */\n  public get processStrings(): boolean {\n    return true;\n  }\n\n  /**\n   * @override\n   */\n  public findMath(_node: N | string[], _options?: OptionList) {\n    return [] as ProtoItem<N, T>[];\n  }\n\n  /**\n   * @override\n   */\n  public abstract compile(math: MathItem<N, T, D>, document: MathDocument<N, T, D>): MmlNode;\n\n  /**\n   * Execute a set of filters, passing them the MathItem and any needed data,\n   *  and return the (possibly modified) data\n   *\n   * @param {FunctionList} filters   The list of functions to be performed\n   * @param {MathItem} math          The math item that is being processed\n   * @param {MathDocument} document  The math document containg the math item\n   * @param {any} data               Whatever other data is needed\n   * @return {any}                   The (possibly modified) data\n   */\n  protected executeFilters(\n    filters: FunctionList, math: MathItem<N, T, D>,\n    document: MathDocument<N, T, D>, data: any\n  ): any {\n    let args = {math: math, document: document, data: data};\n    filters.execute(args);\n    return args.data;\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the interface and abstract class for MathItem objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {MathDocument} from './MathDocument.js';\nimport {InputJax} from './InputJax.js';\nimport {OptionList} from '../util/Options.js';\nimport {MmlNode} from './MmlTree/MmlNode.js';\n\n/*****************************************************************/\n/**\n *  The Location gives a location of a position in a document\n *  (either a node and character position within it, or\n *  an index into a string array, the character position within\n *  the string, and the delimiter at that location).\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport type Location<N, T> = {\n  i?: number;\n  n?: number;\n  delim?: string;\n  node?: N | T;\n};\n\n/*****************************************************************/\n/**\n *  The Metrics object includes the data needed to typeset\n *  a MathItem.\n */\nexport type Metrics = {\n  em: number;\n  ex: number;\n  containerWidth: number;\n  lineWidth: number;\n  scale: number;\n};\n\n/*****************************************************************/\n/**\n *  The MathItem interface\n *\n *  The MathItem is the object that holds the information about a\n *  particular expression on the page, including pointers to\n *  where it is in the document, its compiled version (in the\n *  internal format), its typeset version, its bounding box,\n *  and so on.\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport interface MathItem<N, T, D> {\n  /**\n   * The string representing the expression to be processed\n   */\n  math: string;\n\n  /**\n   * The input jax used to process the math\n   */\n  inputJax: InputJax<N, T, D>;\n\n  /**\n   * Whether the math is in display mode or inline mode\n   */\n  display: boolean;\n\n  /**\n   * Whether this item is an escaped character or not\n   */\n  isEscaped: boolean;\n\n  /**\n   * The start and ending locations in the document of\n   *   this expression\n   */\n  start: Location<N, T>;\n  end: Location<N, T>;\n\n  /**\n   * The internal format for this expression (once compiled)\n   */\n  root: MmlNode;\n\n  /**\n   * The typeset version of the expression (once typeset)\n   */\n  typesetRoot: N;\n\n  /**\n   * The metric information at the location of the math\n   * (the em-size, scaling factor, etc.)\n   */\n  metrics: Metrics;\n\n  /**\n   * Extra data needed by the input or output jax, as needed\n   */\n  inputData: OptionList;\n  outputData: OptionList;\n\n  /**\n   * Perform the renderActions on the document\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   */\n  render(document: MathDocument<N, T, D>): void;\n\n  /**\n   * Rerenders an already rendered item and inserts it into the document\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   * @param {number=} start          The state to start rerendering at (default = RERENDER)\n   */\n  rerender(document: MathDocument<N, T, D>, start?: number): void;\n\n  /**\n   * Converts the expression by calling the render actions until the state matches the end state\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   * @param {number=} end            The state to end rerendering at (default = LAST)\n   */\n  convert(document: MathDocument<N, T, D>, end?: number): void;\n\n  /**\n   * Converts the expression into the internal format by calling the input jax\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   */\n  compile(document: MathDocument<N, T, D>): void;\n\n  /**\n   * Converts the internal format to the typeset version by calling the output jax\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   */\n  typeset(document: MathDocument<N, T, D>): void;\n\n  /**\n   * Inserts the typeset version in place of the original form in the document\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   */\n  updateDocument(document: MathDocument<N, T, D>): void;\n\n  /**\n   * Removes the typeset version from the document, optionally replacing the original\n   * form of the expression and its delimiters.\n   *\n   * @param {boolean} restore  True if the original version is to be restored\n   */\n  removeFromDocument(restore: boolean): void;\n\n  /**\n   * Sets the metric information for this expression\n   *\n   * @param {number} em      The size of 1 em in pixels\n   * @param {number} ex      The size of 1 ex in pixels\n   * @param {number} cwidth  The container width in pixels\n   * @param {number} lwidth  The line breaking width in pixels\n   * @param {number} scale   The scaling factor (unitless)\n   */\n  setMetrics(em: number, ex: number, cwidth: number, lwidth: number, scale: number): void;\n\n  /**\n   * Set or return the current processing state of this expression,\n   * optionally restoring the document if rolling back an expression\n   * that has been added to the document.\n   *\n   * @param {number} state    The state to set for the expression\n   * @param {number} restore  True if the original form should be restored\n   *                           to the document when rolling back a typeset version\n   * @returns {number}        The current state\n   */\n  state(state?: number, restore?: boolean): number;\n\n  /**\n   * Reset the item to its unprocessed state\n   *\n   * @param {number} restore  True if the original form should be restored\n   *                           to the document when rolling back a typeset version\n   */\n  reset(restore?: boolean): void;\n}\n\n/*****************************************************************/\n/**\n *  The ProtoItem interface\n *\n *  This is what is returned by the FindMath class, giving the location\n *  of math within the document, and is used to produce the full\n *  MathItem later (e.g., when the position within a string array\n *  is translated back into the actual node location in the DOM).\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport type ProtoItem<N, T> = {\n  math: string;            // The math expression itself\n  start: Location<N, T>;   // The starting location of the math\n  end: Location<N, T>;     // The ending location of the math\n  open?: string;           // The opening delimiter\n  close?: string;          // The closing delimiter\n  n?: number;              // The index of the string in which this math is found\n  display: boolean;        // True means display mode, false is inline mode\n};\n\n/**\n *  Produce a proto math item that can be turned into a MathItem\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport function protoItem<N, T>(open: string, math: string, close: string, n: number,\n                                start: number, end: number, display: boolean = null) {\n  let item: ProtoItem<N, T> = {open: open, math: math, close: close,\n                               n: n, start: {n: start}, end: {n: end}, display: display};\n  return item;\n}\n\n/*****************************************************************/\n/**\n *  Implements the MathItem class\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport abstract class AbstractMathItem<N, T, D> implements MathItem<N, T, D> {\n\n  /**\n   * The source text for the math (e.g., TeX string)\n   */\n  public math: string;\n\n  /**\n   * The input jax associated with this item\n   */\n\n  public inputJax: InputJax<N, T, D>;\n\n  /**\n   * True when this math is in display mode\n   */\n  public display: boolean;\n\n  /**\n   * Reference to the beginning of the math in the document\n   */\n  public start: Location<N, T>;\n  /**\n   * Reference to the end of the math in the document\n   */\n  public end: Location<N, T>;\n\n  /**\n   * The compiled internal MathML (result of InputJax)\n   */\n  public root: MmlNode = null;\n  /**\n   * The typeset result (result of OutputJax)\n   */\n  public typesetRoot: N = null;\n\n  /**\n   * The metric information about the surrounding environment\n   */\n  public metrics: Metrics = {} as Metrics;\n\n  /**\n   * Data private to the input jax\n   */\n  public inputData: OptionList = {};\n\n  /**\n   * Data private to the output jax\n   */\n  public outputData: OptionList = {};\n\n  /**\n   * The current state of the item (how far in the render actions it has been processed)\n   */\n  protected _state: number = STATE.UNPROCESSED;\n\n  /**\n   * @return {boolean}   True when this item is an escaped delimiter\n   */\n  public get isEscaped(): boolean {\n    return this.display === null;\n  }\n\n  /**\n   * @param {string} math      The math expression for this item\n   * @param {Inputjax} jax     The input jax to use for this item\n   * @param {boolean} display  True if display mode, false if inline\n   * @param {Location} start   The starting position of the math in the document\n   * @param {Location} end     The ending position of the math in the document\n   * @constructor\n   */\n  constructor (math: string, jax: InputJax<N, T, D>, display: boolean = true,\n               start: Location<N, T> = {i: 0, n: 0, delim: ''},\n               end: Location<N, T> = {i: 0, n: 0, delim: ''}) {\n    this.math = math;\n    this.inputJax = jax;\n    this.display = display;\n    this.start = start;\n    this.end = end;\n    this.root = null;\n    this.typesetRoot = null;\n    this.metrics = {} as Metrics;\n    this.inputData = {};\n    this.outputData = {};\n  }\n\n  /**\n   * @override\n   */\n  public render(document: MathDocument<N, T, D>) {\n    document.renderActions.renderMath(this, document);\n  }\n\n  /**\n   * @override\n   */\n  public rerender(document: MathDocument<N, T, D>, start: number = STATE.RERENDER) {\n    if (this.state() >= start) {\n      this.state(start - 1);\n    }\n    document.renderActions.renderMath(this, document, start);\n  }\n\n  /**\n   * @override\n   */\n  public convert(document: MathDocument<N, T, D>, end: number = STATE.LAST) {\n    document.renderActions.renderConvert(this, document, end);\n  }\n\n  /**\n   * @override\n   */\n  public compile(document: MathDocument<N, T, D>) {\n    if (this.state() < STATE.COMPILED) {\n      this.root = this.inputJax.compile(this, document);\n      this.state(STATE.COMPILED);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public typeset(document: MathDocument<N, T, D>) {\n    if (this.state() < STATE.TYPESET) {\n      this.typesetRoot = document.outputJax[this.isEscaped ? 'escaped' : 'typeset'](this, document);\n      this.state(STATE.TYPESET);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public updateDocument(_document: MathDocument<N, T, D>) {}\n\n  /**\n   * @override\n   */\n  public removeFromDocument(_restore: boolean = false) {}\n\n  /**\n   * @override\n   */\n  public setMetrics(em: number, ex: number, cwidth: number, lwidth: number, scale: number) {\n    this.metrics = {\n      em: em, ex: ex,\n      containerWidth: cwidth,\n      lineWidth: lwidth,\n      scale: scale\n    };\n  }\n\n  /**\n   * @override\n   */\n  public state(state: number = null, restore: boolean = false) {\n    if (state != null) {\n      if (state < STATE.INSERTED && this._state >= STATE.INSERTED) {\n        this.removeFromDocument(restore);\n      }\n      if (state < STATE.TYPESET && this._state >= STATE.TYPESET) {\n        this.outputData = {};\n      }\n      if (state < STATE.COMPILED && this._state >= STATE.COMPILED) {\n        this.inputData = {};\n      }\n      this._state = state;\n    }\n    return this._state;\n  }\n\n  /**\n   * @override\n   */\n  public reset(restore: boolean = false) {\n    this.state(STATE.UNPROCESSED, restore);\n  }\n\n}\n\n/*****************************************************************/\n/**\n * The various states that a MathItem (or MathDocument) can be in\n *   (open-ended so that extensions can add to it)\n */\nexport const STATE: {[state: string]: number} = {\n  UNPROCESSED: 0,\n  FINDMATH: 10,\n  COMPILED: 20,\n  CONVERT: 100,\n  METRICS: 110,\n  RERENDER: 125,\n  TYPESET: 150,\n  INSERTED: 200,\n  LAST: 10000\n};\n\n/**\n * Allocate a new named state\n *\n * @param {string} name    The name of the new state\n * @param {number} state   The value for the new state\n */\nexport function newState(name: string, state: number) {\n  if (name in STATE) {\n    throw Error('State ' + name + ' already exists');\n  }\n  STATE[name] = state;\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the TeX InputJax object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AbstractInputJax} from '../core/InputJax.js';\nimport {userOptions, separateOptions, OptionList} from '../util/Options.js';\nimport {MathDocument} from '../core/MathDocument.js';\nimport {MathItem} from '../core/MathItem.js';\nimport {MmlNode} from '../core/MmlTree/MmlNode.js';\nimport {MmlFactory} from '../core/MmlTree/MmlFactory.js';\n\nimport {FindTeX} from './tex/FindTeX.js';\n\nimport FilterUtil from './tex/FilterUtil.js';\nimport NodeUtil from './tex/NodeUtil.js';\nimport TexParser from './tex/TexParser.js';\nimport TexError from './tex/TexError.js';\nimport ParseOptions from './tex/ParseOptions.js';\nimport {TagsFactory} from './tex/Tags.js';\nimport {ParserConfiguration} from './tex/Configuration.js';\n// Import base as it is the default package loaded.\nimport './tex/base/BaseConfiguration.js';\n\n\n/*****************************************************************/\n/*\n *  Implements the TeX class (extends AbstractInputJax)\n */\n\n/**\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport class TeX<N, T, D> extends AbstractInputJax<N, T, D> {\n\n  /**\n   * Name of input jax.\n   * @type {string}\n   */\n  public static NAME: string = 'TeX';\n\n  /**\n   * Default options for the jax.\n   * @type {OptionList}\n   */\n  public static OPTIONS: OptionList = {\n    ...AbstractInputJax.OPTIONS,\n    FindTeX: null,\n    packages: ['base'],\n    // Digit pattern to match numbers.\n    digits: /^(?:[0-9]+(?:\\{,\\}[0-9]{3})*(?:\\.[0-9]*)?|\\.[0-9]+)/,\n    // Maximum size of TeX string to process.\n    maxBuffer: 5 * 1024,\n    formatError: (jax: TeX<any, any, any>, err: TexError) => jax.formatError(err)\n  };\n\n  /**\n   * The FindTeX instance used for locating TeX in strings\n   */\n  protected findTeX: FindTeX<N, T, D>;\n\n  /**\n   * The configuration of the TeX jax.\n   * @type {ParserConfiguration}\n   */\n  protected configuration: ParserConfiguration;\n\n  /**\n   * The LaTeX code that is parsed.\n   * @type {string}\n   */\n  protected latex: string;\n\n  /**\n   * The Math node that results from parsing.\n   * @type {MmlNode}\n   */\n  protected mathNode: MmlNode;\n\n  private _parseOptions: ParseOptions;\n\n  /**\n   * Initialises the configurations.\n   * @param {string[]} packages Names of packages.\n   * @return {Configuration} The configuration object.\n   */\n  protected static configure(packages: (string | [string, number])[]): ParserConfiguration {\n    let configuration = new ParserConfiguration(packages, ['tex']);\n    configuration.init();\n    return configuration;\n  }\n\n\n  /**\n   * Initialises the Tags factory. Add tagging structures from packages and set\n   * tagging to given default.\n   * @param {ParseOptions} options The parse options.\n   * @param {Configuration} configuration The configuration.\n   */\n  protected static tags(options: ParseOptions, configuration: ParserConfiguration) {\n    TagsFactory.addTags(configuration.tags);\n    TagsFactory.setDefault(options.options.tags);\n    options.tags = TagsFactory.getDefault();\n    options.tags.configuration = options;\n  }\n\n\n  /**\n   * @override\n   */\n  constructor(options: OptionList = {}) {\n    const [rest, tex, find] = separateOptions(options, TeX.OPTIONS, FindTeX.OPTIONS);\n    super(tex);\n    this.findTeX = this.options['FindTeX'] || new FindTeX(find);\n    const packages = this.options.packages;\n    const configuration = this.configuration = TeX.configure(packages);\n    const parseOptions = this._parseOptions =\n      new ParseOptions(configuration, [this.options, TagsFactory.OPTIONS]);\n    userOptions(parseOptions.options, rest);\n    configuration.config(this);\n    TeX.tags(parseOptions, configuration);\n    this.postFilters.add(FilterUtil.cleanSubSup, -6);\n    this.postFilters.add(FilterUtil.setInherited, -5);\n    this.postFilters.add(FilterUtil.moveLimits, -4);\n    this.postFilters.add(FilterUtil.cleanStretchy, -3);\n    this.postFilters.add(FilterUtil.cleanAttributes, -2);\n    this.postFilters.add(FilterUtil.combineRelations, -1);\n  }\n\n  /**\n   * @override\n   */\n  public setMmlFactory(mmlFactory: MmlFactory) {\n    super.setMmlFactory(mmlFactory);\n    this._parseOptions.nodeFactory.setMmlFactory(mmlFactory);\n  }\n\n\n  /**\n   * @return {ParseOptions} The parse options that configure this JaX instance.\n   */\n  public get parseOptions(): ParseOptions {\n    return this._parseOptions;\n  }\n\n  /**\n   * @override\n   */\n  public reset(tag: number = 0) {\n    this.parseOptions.tags.reset(tag);\n  }\n\n\n  /**\n   * @override\n   */\n  public compile(math: MathItem<N, T, D>, document: MathDocument<N, T, D>): MmlNode {\n    this.parseOptions.clear();\n    this.executeFilters(this.preFilters, math, document, this.parseOptions);\n    let display = math.display;\n    this.latex = math.math;\n    let node: MmlNode;\n    this.parseOptions.tags.startEquation(math);\n    let globalEnv;\n    try {\n      let parser = new TexParser(this.latex,\n                                 {display: display, isInner: false},\n                                 this.parseOptions);\n      node = parser.mml();\n      globalEnv = parser.stack.global;\n    } catch (err) {\n      if (!(err instanceof TexError)) {\n        throw err;\n      }\n      this.parseOptions.error = true;\n      node = this.options.formatError(this, err);\n    }\n    node = this.parseOptions.nodeFactory.create('node', 'math', [node]);\n    if (globalEnv?.indentalign) {\n      NodeUtil.setAttribute(node, 'indentalign', globalEnv.indentalign);\n    }\n    if (display) {\n      NodeUtil.setAttribute(node, 'display', 'block');\n    }\n    this.parseOptions.tags.finishEquation(math);\n    this.parseOptions.root = node;\n    this.executeFilters(this.postFilters, math, document, this.parseOptions);\n    this.mathNode = this.parseOptions.root;\n    return this.mathNode;\n  }\n\n\n  /**\n   * @override\n   */\n  public findMath(strings: string[]) {\n    return this.findTeX.findMath(strings);\n  }\n\n  /**\n   * Default formatter for error messages:\n   *   wrap an error into a node for output.\n   * @param {TeXError} err The TexError.\n   * @return {Node} The merror node.\n   */\n  public formatError(err: TexError): MmlNode {\n    let message = err.message.replace(/\\n.*/, '');\n    return this.parseOptions.nodeFactory.create(\n      'error', message, err.id, this.latex);\n  }\n\n}\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Utility functions for standard pre and post filters.\n *\n * @author sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport {TEXCLASS, MMLNODE, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport NodeUtil from './NodeUtil.js';\nimport ParseOptions from './ParseOptions.js';\nimport {MmlMo} from '../../core/MmlTree/MmlNodes/mo.js';\nimport {Attributes} from '../../core/MmlTree/Attributes.js';\n\n\nnamespace FilterUtil {\n\n  /**\n   * Visitor to set stretchy attributes to false on <mo> elements, if they are\n   * not used as delimiters. Also wraps non-stretchy infix delimiters into a\n   * TeXAtom.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanStretchy = function(arg: {math: any, data: ParseOptions}) {\n    let options = arg.data;\n    for (let mo of options.getList('fixStretchy')) {\n      if (NodeUtil.getProperty(mo, 'fixStretchy')) {\n        let symbol = NodeUtil.getForm(mo);\n        if (symbol && symbol[3] && symbol[3]['stretchy']) {\n          NodeUtil.setAttribute(mo, 'stretchy', false);\n        }\n        const parent = mo.parent;\n        if (!NodeUtil.getTexClass(mo) && (!symbol || !symbol[2])) {\n          const texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);\n          parent.replaceChild(texAtom, mo);\n          texAtom.inheritAttributesFrom(mo);\n        }\n        NodeUtil.removeProperties(mo, 'fixStretchy');\n      }\n    }\n  };\n\n\n  /**\n   * Visitor that removes superfluous attributes from nodes. I.e., if a node has\n   * an attribute, which is also an inherited attribute it will be removed. This\n   * is necessary as attributes are set bottom up in the parser.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanAttributes = function(arg: {data: ParseOptions}) {\n    let node = arg.data.root as MmlNode;\n    node.walkTree((mml: MmlNode, _d: any) => {\n      let attribs = mml.attributes as any;\n      if (!attribs) {\n        return;\n      }\n      const keep = new Set((attribs.get('mjx-keep-attrs') || '').split(/ /));\n      delete (attribs.getAllAttributes())['mjx-keep-attrs'];\n      for (const key of attribs.getExplicitNames()) {\n        if (!keep.has(key) && attribs.attributes[key] === mml.attributes.getInherited(key)) {\n          delete attribs.attributes[key];\n        }\n      }\n    }, {});\n  };\n\n\n  /**\n   * Combine adjacent <mo> elements that are relations (since MathML treats the\n   * spacing very differently)\n   * @param {ParseOptions} data The parse options.\n   */\n  export let combineRelations = function(arg: {data: ParseOptions}) {\n    const remove: MmlNode[] = [];\n    for (let mo of arg.data.getList('mo')) {\n      if (mo.getProperty('relationsCombined') || !mo.parent ||\n          (mo.parent && !NodeUtil.isType(mo.parent, 'mrow')) ||\n          NodeUtil.getTexClass(mo) !== TEXCLASS.REL) {\n        // @test Prime, PrimeSup, Named Function\n        continue;\n      }\n      let mml = mo.parent;\n      let m2: MmlNode;\n      let children = mml.childNodes as MMLNODE[];\n      let next = children.indexOf(mo) + 1;\n      let variantForm = NodeUtil.getProperty(mo, 'variantForm');\n      while (next < children.length && (m2 = children[next]) &&\n             NodeUtil.isType(m2, 'mo') &&\n             NodeUtil.getTexClass(m2) === TEXCLASS.REL) {\n        if (variantForm === NodeUtil.getProperty(m2, 'variantForm') &&\n            _compareExplicit(mo, m2)) {\n          // @test Shift Left, Less Equal,\n          //       Multirel Font X, Multirel Mathvariant X\n          NodeUtil.appendChildren(mo, NodeUtil.getChildren(m2));\n          // This treatment means we might loose some inheritance structure, but\n          // no properties.\n          _copyExplicit(['stretchy', 'rspace'], mo, m2);\n          for (const name of m2.getPropertyNames()) {\n            mo.setProperty(name, m2.getProperty(name));\n          }\n          children.splice(next, 1);\n          remove.push(m2);\n          m2.parent = null;\n          m2.setProperty('relationsCombined', true);\n        } else {\n          // @test Preset Rspace Lspace\n          if (mo.attributes.getExplicit('rspace') == null) {\n            // @test Mulitrel Mathvariant 3, Mulitrel Mathvariant 4\n            NodeUtil.setAttribute(mo, 'rspace', '0pt');\n          }\n          if (m2.attributes.getExplicit('lspace') == null) {\n            // @test Mulitrel Mathvariant 3, Mulitrel Mathvariant 4\n            NodeUtil.setAttribute(m2, 'lspace', '0pt');\n          }\n          break;\n        }\n      }\n      mo.attributes.setInherited('form', (mo as MmlMo).getForms()[0]);\n    }\n    arg.data.removeFromList('mo', remove);\n  };\n\n\n  /**\n   * Copies the specified explicit attributes from node2 to node1.\n   * @param {string[]} attrs List of explicit attribute names.\n   * @param {MmlNode} node1 The goal node.\n   * @param {MmlNode} node2 The source node.\n   */\n  let _copyExplicit = function(attrs: string[],\n                               node1: MmlNode, node2: MmlNode) {\n    let attr1 = node1.attributes;\n    let attr2 = node2.attributes;\n    attrs.forEach(x => {\n      let attr = attr2.getExplicit(x);\n      if (attr != null) {\n        // @test Infix Stretchy Right, Preset Lspace Rspace\n        attr1.set(x, attr);\n      }\n    });\n  };\n\n\n  /**\n   * Compares the explicit attributes of two nodes. Returns true if they\n   * coincide, with the following exceptions:\n   *   - lspace attribute of node1 is ignored.\n   *   - rspace attribute of node2 is ignored.\n   *   - stretchy=false attributes are ignored.\n   * @param {MmlNode} node1 The first node.\n   * @param {MmlNode} node2 Its next sibling.\n   */\n  let _compareExplicit = function(node1: MmlNode, node2: MmlNode) {\n    let filter = (attr: Attributes, space: string): string[] => {\n      let exp = attr.getExplicitNames();\n      return exp.filter(x => {\n        return x !== space &&\n          (x !== 'stretchy' ||\n           attr.getExplicit('stretchy'));\n      });\n    };\n    let attr1 = node1.attributes;\n    let attr2 = node2.attributes;\n    let exp1 = filter(attr1, 'lspace');\n    let exp2 = filter(attr2, 'rspace');\n    if (exp1.length !== exp2.length) {\n      return false;\n    }\n    for (let name of exp1) {\n      if (attr1.getExplicit(name) !== attr2.getExplicit(name)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Cleans msubsup and munderover elements.\n   * @param {ParseOptions} options The parse options.\n   * @param {string} low String representing the lower part of the expression.\n   * @param {string} up String representing the upper part.\n   */\n  let _cleanSubSup = function(options: ParseOptions, low: string, up: string) {\n    const remove: MmlNode[] = [];\n    for (let mml of options.getList('m' + low + up) as any[]) {\n      const children = mml.childNodes;\n      if (children[mml[low]] && children[mml[up]]) {\n        continue;\n      }\n      const parent = mml.parent;\n      let newNode = (children[mml[low]] ?\n                 options.nodeFactory.create('node', 'm' + low, [children[mml.base], children[mml[low]]]) :\n                 options.nodeFactory.create('node', 'm' + up, [children[mml.base], children[mml[up]]]));\n      NodeUtil.copyAttributes(mml, newNode);\n      if (parent) {\n        parent.replaceChild(newNode, mml);\n      } else {\n        options.root = newNode;\n      }\n      remove.push(mml);\n    }\n    options.removeFromList('m' + low + up, remove);\n  };\n\n\n  /**\n   * Visitor that rewrites incomplete msubsup/munderover elements in the given\n   * node into corresponding msub/sup/under/over nodes.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanSubSup = function(arg: {math: any, data: ParseOptions}) {\n    let options = arg.data;\n    if (options.error) {\n      return;\n    }\n    _cleanSubSup(options, 'sub', 'sup');\n    _cleanSubSup(options, 'under', 'over');\n  };\n\n\n  /**\n   * Looks through the list of munderover elements for ones that have\n   * movablelimits and bases that are not mo's, and creates new msubsup\n   * elements to replace them if they aren't in displaystyle.\n   *\n   * @param {MmlNode} ath The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  let _moveLimits = function (options: ParseOptions, underover: string, subsup: string) {\n    const remove: MmlNode[] = [];\n    for (const mml of options.getList(underover)) {\n      if (mml.attributes.get('displaystyle')) {\n        continue;\n      }\n      const base = mml.childNodes[(mml as any).base] as MmlNode;\n      const mo = base.coreMO();\n      if (base.getProperty('movablelimits') && !mo.attributes.getExplicit('movablelimits')) {\n        let node = options.nodeFactory.create('node', subsup, mml.childNodes);\n        NodeUtil.copyAttributes(mml, node);\n        if (mml.parent) {\n          mml.parent.replaceChild(node, mml);\n        } else {\n          options.root = node;\n        }\n        remove.push(mml);\n      }\n    }\n    options.removeFromList(underover, remove);\n  };\n\n  /**\n   * Visitor that rewrites in-line munderover elements with movablelimits but bases\n   * that are not mo's into explicit msubsup elements.\n   *\n   * @param {ParseOptions} data  The parse options to use\n   */\n  export let moveLimits = function (arg: {data: ParseOptions}) {\n    const options = arg.data;\n    _moveLimits(options, 'munderover', 'msubsup');\n    _moveLimits(options, 'munder', 'msub');\n    _moveLimits(options, 'mover', 'msup');\n  };\n\n\n  /**\n   * Recursively sets the inherited attributes on the math tree.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let setInherited = function(arg: {math: any, data: ParseOptions}) {\n    arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);\n  };\n\n}\n\n\nexport default FilterUtil;\n","/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the TeX version of the FindMath object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AbstractFindMath} from '../../core/FindMath.js';\nimport {OptionList} from '../../util/Options.js';\nimport {sortLength, quotePattern} from '../../util/string.js';\nimport {ProtoItem, protoItem} from '../../core/MathItem.js';\n\n/**\n * Shorthand types for data about end delimiters and delimiter pairs\n */\nexport type EndItem = [string, boolean, RegExp];\nexport type Delims = [string, string];\n\n/*****************************************************************/\n/*\n *  Implements the FindTeX class (extends AbstractFindMath)\n *\n *  Locates TeX expressions within strings\n */\n\n/*\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport class FindTeX<N, T, D> extends AbstractFindMath<N, T, D> {\n\n  /**\n   * @type {OptionList}\n   */\n  public static OPTIONS: OptionList = {\n    inlineMath: [              // The start/end delimiter pairs for in-line math\n      //  ['$', '$'],              //  (comment out any you don't want, or add your own, but\n      ['\\\\(', '\\\\)']           //  be sure that you don't have an extra comma at the end)\n    ],\n\n    displayMath: [             // The start/end delimiter pairs for display math\n      ['$$', '$$'],            //  (comment out any you don't want, or add your own, but\n      ['\\\\[', '\\\\]']           //  be sure that you don't have an extra comma at the end)\n    ],\n\n    processEscapes: true,      // set to true to allow \\$ to produce a dollar without\n    //   starting in-line math mode\n    processEnvironments: true, // set to true to process \\begin{xxx}...\\end{xxx} outside\n    //   of math mode, false to prevent that\n    processRefs: true,         // set to true to process \\ref{...} outside of math mode\n  };\n\n  /**\n   * The regular expression for any starting delimiter\n   */\n  protected start: RegExp;\n\n  /**\n   * The end-delimiter data keyed to the opening delimiter string\n   */\n  protected end: {[name: string]: EndItem};\n\n  /**\n   * False if the configuration has no delimiters (so search can be skipped), true otherwise\n   */\n  protected hasPatterns: boolean;\n\n  /**\n   * The index of the \\begin...\\end pattern in the regex match array\n   */\n  protected env: number;\n\n  /**\n   * The index of the \\ref and escaped character patters in the regex match array\n   */\n  protected sub: number;\n\n  /**\n   * @override\n   */\n  constructor(options: OptionList) {\n    super(options);\n    this.getPatterns();\n  }\n\n  /**\n   * Create the patterns needed for searching the strings for TeX\n   *   based on the configuration options\n   */\n  protected getPatterns() {\n    let options = this.options;\n    let starts: string[] = [], parts: string[] = [], subparts: string[] = [];\n    this.end = {};\n    this.env = this.sub = 0;\n    let i = 1;\n    options['inlineMath'].forEach((delims: Delims) => this.addPattern(starts, delims, false));\n    options['displayMath'].forEach((delims: Delims) => this.addPattern(starts, delims, true));\n    if (starts.length) {\n      parts.push(starts.sort(sortLength).join('|'));\n    }\n    if (options['processEnvironments']) {\n      parts.push('\\\\\\\\begin\\\\s*\\\\{([^}]*)\\\\}');\n      this.env = i;\n      i++;\n    }\n    if (options['processEscapes']) {\n      subparts.push('\\\\\\\\([\\\\\\\\$])');\n    }\n    if (options['processRefs']) {\n      subparts.push('(\\\\\\\\(?:eq)?ref\\\\s*\\\\{[^}]*\\\\})');\n    }\n    if (subparts.length) {\n      parts.push('(' + subparts.join('|') + ')');\n      this.sub = i;\n    }\n    this.start = new RegExp(parts.join('|'), 'g');\n    this.hasPatterns = (parts.length > 0);\n  }\n\n  /**\n   * Add the needed patterns for a pair of delimiters\n   *\n   * @param {string[]} starts  Array of starting delimiter strings\n   * @param {Delims} delims    Array of delimiter strings, as [start, end]\n   * @param {boolean} display  True if the delimiters are for display mode\n   */\n  protected addPattern(starts: string[], delims: Delims, display: boolean) {\n    let [open, close] = delims;\n    starts.push(quotePattern(open));\n    this.end[open] = [close, display, this.endPattern(close)];\n  }\n\n  /**\n   * Create the pattern for a close delimiter\n   *\n   * @param {string} end   The end delimiter text\n   * @param {string} endp  The end delimiter pattern (overrides the literal end pattern)\n   * @return {RegExp}      The regular expression for the end delimiter\n   */\n  protected endPattern(end: string, endp?: string): RegExp {\n    return new RegExp((endp || quotePattern(end)) + '|\\\\\\\\(?:[a-zA-Z]|.)|[{}]', 'g');\n  }\n\n  /**\n   * Search for the end delimiter given the start delimiter,\n   *   skipping braced groups, and control sequences that aren't\n   *   the close delimiter.\n   *\n   * @param {string} text            The string being searched for the end delimiter\n   * @param {number} n               The index of the string being searched\n   * @param {RegExpExecArray} start  The result array from the start-delimiter search\n   * @param {EndItem} end            The end-delimiter data corresponding to the start delimiter\n   * @return {ProtoItem<N,T>}        The proto math item for the math, if found\n   */\n  protected findEnd(text: string, n: number, start: RegExpExecArray, end: EndItem): ProtoItem<N, T> {\n    let [close, display, pattern] = end;\n    let i = pattern.lastIndex = start.index + start[0].length;\n    let match: RegExpExecArray, braces: number = 0;\n    while ((match = pattern.exec(text))) {\n      if ((match[1] || match[0]) === close && braces === 0) {\n        return protoItem<N, T>(start[0], text.substr(i, match.index - i), match[0],\n                               n, start.index, match.index + match[0].length, display);\n      } else if (match[0] === '{') {\n        braces++;\n      } else if (match[0] === '}' && braces) {\n        braces--;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Search a string for math delimited by one of the delimiter pairs,\n   *   or by \\begin{env}...\\end{env}, or \\eqref{...}, \\ref{...}, \\\\, or \\$.\n   *\n   * @param {ProtoItem[]} math  The array of proto math items located so far\n   * @param {number} n          The index of the string being searched\n   * @param {string} text       The string being searched\n   */\n  protected findMathInString(math: ProtoItem<N, T>[], n: number, text: string) {\n    let start, match;\n    this.start.lastIndex = 0;\n    while ((start = this.start.exec(text))) {\n      if (start[this.env] !== undefined && this.env) {\n        let end = '\\\\\\\\end\\\\s*(\\\\{' + quotePattern(start[this.env]) + '\\\\})';\n        match = this.findEnd(text, n, start, ['{' + start[this.env] + '}', true, this.endPattern(null, end)]);\n        if (match) {\n          match.math = match.open + match.math + match.close;\n          match.open = match.close = '';\n        }\n      } else if (start[this.sub] !== undefined && this.sub) {\n        let math = start[this.sub];\n        let end = start.index + start[this.sub].length;\n        if (math.length === 2) {\n          match = protoItem<N, T>('', math.substr(1), '', n, start.index, end);\n        } else {\n          match = protoItem<N, T>('', math, '', n, start.index, end, false);\n        }\n      } else {\n        match = this.findEnd(text, n, start, this.end[start[0]]);\n      }\n      if (match) {\n        math.push(match);\n        this.start.lastIndex = match.end.n;\n      }\n    }\n  }\n\n  /**\n   * Search for math in an array of strings and return an array of matches.\n   *\n   * @override\n   */\n  public findMath(strings: string[]) {\n    let math: ProtoItem<N, T>[] = [];\n    if (this.hasPatterns) {\n      for (let i = 0, m = strings.length; i < m; i++) {\n        this.findMathInString(math, i, strings[i]);\n      }\n    }\n    return math;\n  }\n\n}\n"],"names":["options","CLASS","this","constructor","userOptions","defaultOptions","OPTIONS","AbstractFindMath","adaptor","mmlFactory","preFilters","FunctionList","postFilters","NAME","setAdaptor","setMmlFactory","initialize","reset","findMath","_node","_options","executeFilters","filters","math","document","data","args","execute","AbstractInputJax","open","close","n","start","end","display","jax","i","delim","root","typesetRoot","metrics","inputData","outputData","_state","STATE","UNPROCESSED","inputJax","render","renderActions","renderMath","rerender","RERENDER","state","convert","LAST","renderConvert","compile","COMPILED","typeset","TYPESET","outputJax","isEscaped","updateDocument","_document","removeFromDocument","_restore","setMetrics","em","ex","cwidth","lwidth","scale","containerWidth","lineWidth","restore","INSERTED","AbstractMathItem","FINDMATH","CONVERT","METRICS","name","Error","separateOptions","TeX","FindTeX","rest","tex","find","findTeX","packages","configuration","configure","parseOptions","_parseOptions","TagsFactory","config","tags","add","cleanSubSup","setInherited","moveLimits","cleanStretchy","cleanAttributes","combineRelations","ParserConfiguration","init","addTags","setDefault","getDefault","nodeFactory","tag","clear","node","globalEnv","latex","startEquation","parser","isInner","mml","stack","global","err","error","formatError","create","indentalign","setAttribute","finishEquation","mathNode","strings","message","replace","id","digits","maxBuffer","FilterUtil","arg","getList","mo","getProperty","symbol","getForm","parent","getTexClass","texAtom","replaceChild","inheritAttributesFrom","removeProperties","walkTree","_d","attribs","attributes","keep","Set","get","split","getAllAttributes","getExplicitNames","key","has","getInherited","remove","isType","TEXCLASS","REL","m2","children","childNodes","next","indexOf","variantForm","length","_compareExplicit","getExplicit","appendChildren","getChildren","_copyExplicit","getPropertyNames","setProperty","splice","push","getForms","removeFromList","attrs","node1","node2","attr1","attr2","forEach","x","attr","set","filter","space","exp1","exp2","_cleanSubSup","low","up","newNode","base","copyAttributes","_moveLimits","underover","subsup","coreMO","setInheritedAttributes","getPatterns","starts","parts","subparts","env","sub","delims","addPattern","sort","sortLength","join","RegExp","hasPatterns","quotePattern","endPattern","endp","findEnd","text","match","pattern","lastIndex","index","braces","exec","protoItem","substr","findMathInString","undefined","m","inlineMath","displayMath","processEscapes","processEnvironments","processRefs"],"sourceRoot":""}